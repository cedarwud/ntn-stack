import React, { useState, useEffect } from 'react'
import { netStackApi } from '../../services/netstack-api'
import {
    useNetStackData,
    useDataSourceStatus,
} from '../../contexts/DataSyncContext'
import {
    realConnectionManager,
    RealConnectionInfo,
    RealHandoverStatus,
} from '../../services/realConnectionService'
import './HandoverPerformanceDashboard.scss'

interface HandoverPerformanceDashboardProps {
    enabled: boolean
}

interface HandoverMetrics {
    totalHandovers: number
    successfulHandovers: number
    failedHandovers: number
    averageHandoverTime: number
    predictionAccuracy: number
    currentActiveHandovers: number
    handoverSuccessRate: number
    averagePredictionTime: number
    networkDowntime: number
    qosImpact: number
}

interface HandoverEvent {
    id: string
    timestamp: number
    uavId: string
    fromSatellite: string
    toSatellite: string
    duration: number
    status: 'success' | 'failed' | 'in_progress'
    reason: string
    predictionTime: number
    executionTime: number
}

interface PredictionAccuracyData {
    timeWindow: string
    accuracy: number
    totalPredictions: number
    correctPredictions: number
}

const HandoverPerformanceDashboard: React.FC<
    HandoverPerformanceDashboardProps
> = ({ enabled }) => {
    // ‰ΩøÁî®Êï∏ÊìöÂêåÊ≠•‰∏ä‰∏ãÊñá
    const { isConnected: netstackConnected } = useNetStackData()
    const { dataSource } = useDataSourceStatus()

    const [metrics, setMetrics] = useState<HandoverMetrics>({
        totalHandovers: 15,
        successfulHandovers: 13,
        failedHandovers: 2,
        averageHandoverTime: 2340,
        predictionAccuracy: 87.5,
        currentActiveHandovers: 2,
        handoverSuccessRate: 86.7,
        averagePredictionTime: 125,
        networkDowntime: 480,
        qosImpact: 13.3,
    })

    const [recentEvents, setRecentEvents] = useState<HandoverEvent[]>([])
    const [accuracyHistory, setAccuracyHistory] = useState<
        PredictionAccuracyData[]
    >([])
    const [timeRange, setTimeRange] = useState<'1h' | '6h' | '24h' | '7d'>('1h')
    const [isLoading, setIsLoading] = useState(false)
    const [error, setError] = useState<string | null>(null)
    const [realConnectionData, setRealConnectionData] = useState<{
        connections: Map<string, RealConnectionInfo>
        handovers: Map<string, RealHandoverStatus>
    }>({ connections: new Map(), handovers: new Map() })

    // Âü∫ÊñºÂÖ®Â±ÄÊï∏ÊìöÂêåÊ≠•ÁãÄÊÖãÊ±∫ÂÆöÊòØÂê¶‰ΩøÁî®ÁúüÂØ¶Êï∏Êìö
    const useRealData = netstackConnected && dataSource !== 'simulated'

    // ‰ΩøÁî®ÁúüÂØ¶ NetStack API Áç≤ÂèñÊïàËÉΩÊï∏Êìö
    useEffect(() => {
        if (!enabled) return

        const fetchRealMetrics = async () => {
            if (!useRealData) return

            setIsLoading(true)
            setError(null)

            try {
                console.log('üî• Áç≤ÂèñÁúüÂØ¶ NetStack ÊïàËÉΩÊåáÊ®ô...')

                // ‰∏¶Ë°åÁç≤ÂèñÂ§öÂÄã API Êï∏Êìö
                const [coreSyncStatus, handoverMetrics, recentEvents] =
                    await Promise.all([
                        netStackApi.getCoreSync(),
                        netStackApi.getHandoverLatencyMetrics().catch(() => []), // Â¶ÇÊûúÂ§±ÊïóËøîÂõûÁ©∫Êï∏ÁµÑ
                        netStackApi.getRecentSyncEvents().catch(() => []), // Â¶ÇÊûúÂ§±ÊïóËøîÂõûÁ©∫Êï∏ÁµÑ
                    ])

                console.log('‚úÖ NetStack ÊïàËÉΩÊï∏Êìö:', {
                    coreSyncStatus,
                    handoverMetrics: handoverMetrics.length,
                    recentEvents: recentEvents.length,
                })

                // Êõ¥Êñ∞ÁúüÂØ¶ÊåáÊ®ô
                const realMetrics: HandoverMetrics = {
                    totalHandovers:
                        coreSyncStatus.statistics.total_sync_operations || 0,
                    successfulHandovers:
                        coreSyncStatus.statistics.successful_syncs || 0,
                    failedHandovers:
                        coreSyncStatus.statistics.failed_syncs || 0,
                    averageHandoverTime:
                        coreSyncStatus.statistics.average_sync_time_ms || 0,
                    predictionAccuracy:
                        coreSyncStatus.ieee_infocom_2024_features
                            .binary_search_refinement * 100 || 0,
                    currentActiveHandovers:
                        coreSyncStatus.service_info.active_tasks || 0,
                    handoverSuccessRate:
                        coreSyncStatus.statistics.total_sync_operations > 0
                            ? (coreSyncStatus.statistics.successful_syncs /
                                  coreSyncStatus.statistics
                                      .total_sync_operations) *
                              100
                            : 0,
                    averagePredictionTime:
                        coreSyncStatus.sync_performance.overall_accuracy_ms ||
                        0,
                    networkDowntime: coreSyncStatus.statistics.uptime_percentage
                        ? (100 - coreSyncStatus.statistics.uptime_percentage) *
                          60 *
                          60 *
                          1000 // ËΩâÁÇ∫ ms
                        : 0,
                    qosImpact:
                        coreSyncStatus.sync_performance.overall_accuracy_ms > 50
                            ? Math.min(
                                  100,
                                  (coreSyncStatus.sync_performance
                                      .overall_accuracy_ms -
                                      50) /
                                      5
                              )
                            : 0,
                }

                setMetrics(realMetrics)

                // ËΩâÊèõÊèõÊâãÊ∏¨ÈáèÊï∏ÊìöÁÇ∫‰∫ã‰ª∂Ê†ºÂºè
                if (handoverMetrics.length > 0) {
                    const events: HandoverEvent[] = handoverMetrics
                        .slice(0, 20)
                        .map((metric) => ({
                            id: metric.measurement_id,
                            timestamp: metric.timestamp,
                            uavId: metric.ue_id,
                            fromSatellite: metric.source_satellite,
                            toSatellite: metric.target_satellite,
                            duration: metric.latency_ms,
                            status:
                                metric.success_rate > 0.8
                                    ? 'success'
                                    : 'failed',
                            reason: `${metric.handover_type} handover`,
                            predictionTime:
                                metric.additional_metrics.signaling_overhead ||
                                0,
                            executionTime:
                                metric.additional_metrics
                                    .interruption_time_ms || 0,
                        }))

                    setRecentEvents(events)
                }
                
                // Êõ¥Êñ∞ÁúüÂØ¶ÈÄ£Êé•Êï∏ÊìöÁãÄÊÖã
                const connections = realConnectionManager.getAllConnections();
                const handovers = realConnectionManager.getAllHandovers();
                setRealConnectionData({ connections, handovers });

                // Êõ¥Êñ∞Ê∫ñÁ¢∫ÁéáÊ≠∑Âè≤ÔºàÂü∫ÊñºÁúüÂØ¶Êï∏ÊìöÔºâ
                const newAccuracyData: PredictionAccuracyData = {
                    timeWindow: new Date().toLocaleTimeString(),
                    accuracy: realMetrics.predictionAccuracy,
                    totalPredictions: realMetrics.totalHandovers,
                    correctPredictions: realMetrics.successfulHandovers,
                }

                setAccuracyHistory((prev) => [
                    newAccuracyData,
                    ...prev.slice(0, 19),
                ])
            } catch (error) {
                console.error('‚ùå Áç≤Âèñ NetStack ÊïàËÉΩÊåáÊ®ôÂ§±Êïó:', error)
                setError(
                    error instanceof Error ? error.message : 'Unknown error'
                )

                // Ê≥®ÊÑèÔºöuseRealData ÁèæÂú®Áî±ÂÖ®Â±ÄÁãÄÊÖãÊéßÂà∂Ôºå‰∏çÈúÄË¶ÅÊâãÂãïË®≠ÁΩÆ
                console.warn('‚ö†Ô∏è ÂõûÈÄÄÂà∞Ê®°Êì¨Êï∏ÊìöÊ®°Âºè')
            } finally {
                setIsLoading(false)
            }
        }

        // Á´ãÂç≥Áç≤Âèñ‰∏ÄÊ¨°Êï∏Êìö
        fetchRealMetrics()

        // Â¶ÇÊûú‰ΩøÁî®ÁúüÂØ¶Êï∏ÊìöÔºåÊØè30ÁßíÊõ¥Êñ∞‰∏ÄÊ¨°
        const interval = setInterval(() => {
            if (useRealData) {
                fetchRealMetrics()
            }
        }, 30000)

        return () => clearInterval(interval)
    }, [enabled, useRealData])

    // ÂõûÈÄÄÁöÑÊ®°Êì¨Êï∏ÊìöÊõ¥Êñ∞ÔºàÁï∂ÁúüÂØ¶ API ‰∏çÂèØÁî®ÊôÇÔºâ
    useEffect(() => {
        if (!enabled || useRealData) return

        console.log('‚ö†Ô∏è ‰ΩøÁî®Ê®°Êì¨Êï∏ÊìöÊõ¥Êñ∞ÊïàËÉΩÊåáÊ®ô')

        const updateSimulatedMetrics = () => {
            const newEvent: HandoverEvent = {
                id: `sim_event_${Date.now()}`,
                timestamp: Date.now(),
                uavId: `UAV_${Math.floor(Math.random() * 10) + 1}`,
                fromSatellite: `SAT_${Math.floor(Math.random() * 5) + 1}`,
                toSatellite: `SAT_${Math.floor(Math.random() * 5) + 6}`,
                duration: 1500 + Math.random() * 3000,
                status: Math.random() > 0.15 ? 'success' : 'failed',
                reason: getRandomReason(),
                predictionTime: 50 + Math.random() * 200,
                executionTime: 1000 + Math.random() * 2000,
            }

            setRecentEvents((prev) => [newEvent, ...prev.slice(0, 19)])

            setMetrics((prev) => {
                const totalHandovers = prev.totalHandovers + 1
                const successfulHandovers =
                    prev.successfulHandovers +
                    (newEvent.status === 'success' ? 1 : 0)
                const failedHandovers =
                    prev.failedHandovers +
                    (newEvent.status === 'failed' ? 1 : 0)

                return {
                    ...prev,
                    totalHandovers,
                    successfulHandovers,
                    failedHandovers,
                    averageHandoverTime:
                        (prev.averageHandoverTime * (totalHandovers - 1) +
                            newEvent.duration) /
                        totalHandovers,
                    predictionAccuracy: 85 + Math.random() * 12,
                    currentActiveHandovers: Math.floor(Math.random() * 5),
                    handoverSuccessRate:
                        (successfulHandovers / totalHandovers) * 100,
                    averagePredictionTime:
                        (prev.averagePredictionTime * (totalHandovers - 1) +
                            newEvent.predictionTime) /
                        totalHandovers,
                    networkDowntime:
                        prev.networkDowntime +
                        (newEvent.status === 'failed' ? newEvent.duration : 0),
                    qosImpact: Math.max(
                        0,
                        100 - (successfulHandovers / totalHandovers) * 100
                    ),
                }
            })

            // Êõ¥Êñ∞Ê∫ñÁ¢∫ÁéáÊ≠∑Âè≤ (Êõ¥È†ªÁπÅ)
            if (Math.random() < 0.6) {
                const newAccuracyData: PredictionAccuracyData = {
                    timeWindow: new Date().toLocaleTimeString(),
                    accuracy: 85 + Math.random() * 12,
                    totalPredictions: Math.floor(Math.random() * 20) + 10,
                    correctPredictions: 0,
                }
                newAccuracyData.correctPredictions = Math.floor(
                    (newAccuracyData.totalPredictions *
                        newAccuracyData.accuracy) /
                        100
                )

                setAccuracyHistory((prev) => [
                    newAccuracyData,
                    ...prev.slice(0, 49),
                ])
            }
        }

        // Á´ãÂç≥Áî¢Áîü‰∏Ä‰∫õÂàùÂßã‰∫ã‰ª∂
        for (let i = 0; i < 8; i++) {
            setTimeout(() => updateSimulatedMetrics(), i * 500)
        }

        // ÁÑ∂ÂæåÊ≠£Â∏∏ÈñìÈöîÊõ¥Êñ∞
        const interval = setInterval(
            updateSimulatedMetrics,
            2000 + Math.random() * 3000
        )

        return () => clearInterval(interval)
    }, [enabled, useRealData])

    const getRandomReason = (): string => {
        const reasons = [
            '‰ø°ËôüÂìÅË≥™‰∏ãÈôç',
            'Ë°õÊòü‰ª∞ËßíÈÅé‰Ωé',
            'Ë≤†ËºâÂπ≥Ë°°',
            'ËªåÈÅìËΩâÊèõ',
            'Âπ≤ÊìæÈÅøÂÖç',
            'Á∂≠Ë≠∑ÈúÄÊ±Ç',
        ]
        return reasons[Math.floor(Math.random() * reasons.length)]
    }

    const getStatusColor = (status: string): string => {
        switch (status) {
            case 'success':
                return '#52c41a'
            case 'failed':
                return '#ff4d4f'
            case 'in_progress':
                return '#1890ff'
            default:
                return '#d9d9d9'
        }
    }

    // ÁßªÈô§Êú™‰ΩøÁî®ÁöÑÂáΩÊï∏

    if (!enabled) return null

    return (
        <div className="handover-performance-dashboard">
            <div className="dashboard-header">
                <div className="header-main">
                    <h2>üîÑ Ë°õÊòüÊèõÊâãÊÄßËÉΩÁõ£Êéß</h2>
                    {/* üìä Êï∏ÊìöÊ∫êÁãÄÊÖãÊåáÁ§∫Âô® */}
                    <div className="data-source-indicator" style={{
                        display: 'inline-flex',
                        alignItems: 'center',
                        gap: '8px',
                        marginLeft: '16px',
                        fontSize: '12px',
                        fontWeight: 'bold'
                    }}>
                        <div style={{
                            padding: '4px 8px',
                            borderRadius: '4px',
                            backgroundColor: useRealData ? 'rgba(40, 167, 69, 0.9)' : 'rgba(255, 193, 7, 0.9)',
                            color: useRealData ? '#fff' : '#000'
                        }}>
                            {useRealData ? 'üêà ÁúüÂØ¶Êï∏Êìö' : '‚ö†Ô∏è Ê®°Êì¨Êï∏Êìö'}
                        </div>
                        {useRealData && realConnectionData.connections.size > 0 && (
                            <div style={{
                                padding: '4px 8px',
                                borderRadius: '4px',
                                backgroundColor: 'rgba(23, 162, 184, 0.9)',
                                color: '#fff'
                            }}>
                                {realConnectionData.connections.size} ÈÄ£Êé•
                            </div>
                        )}
                        {isLoading && (
                            <div style={{
                                padding: '4px 8px',
                                borderRadius: '4px',
                                backgroundColor: 'rgba(108, 117, 125, 0.9)',
                                color: '#fff'
                            }}>
                                üîÑ Êõ¥Êñ∞‰∏≠
                            </div>
                        )}
                    </div>
                </div>

                <div className="time-range-selector">
                    {(['1h', '6h', '24h', '7d'] as const).map((range) => (
                        <button
                            key={range}
                            className={`time-range-btn ${
                                timeRange === range ? 'active' : ''
                            }`}
                            onClick={() => setTimeRange(range)}
                        >
                            {range}
                        </button>
                    ))}
                </div>
            </div>

            {/* ÈóúÈçµÊåáÊ®ôÂç°Áâá */}
            <div className="metrics-grid">
                <div className="metric-card primary">
                    <div className="metric-header">
                        <span className="metric-icon">üìä</span>
                        <h3>Á∏ΩÊèõÊâãÊ¨°Êï∏</h3>
                    </div>
                    <div className="metric-value">{metrics.totalHandovers}</div>
                    <div className="metric-trend up">
                        <span className="trend-icon">‚Üó</span>
                        <span>
                            +{Math.floor(Math.random() * 10) + 1}% vs ‰∏äÂ∞èÊôÇ
                        </span>
                    </div>
                </div>

                <div className="metric-card success">
                    <div className="metric-header">
                        <span className="metric-icon">‚úÖ</span>
                        <h3>ÊàêÂäüÁéá</h3>
                    </div>
                    <div className="metric-value">
                        {metrics.handoverSuccessRate.toFixed(1)}%
                    </div>
                    <div className="metric-trend stable">
                        <span className="trend-icon">‚Üí</span>
                        <span>{useRealData ? 'ÁúüÂØ¶Êï∏Êìö' : 'Á©©ÂÆö'}</span>
                    </div>
                </div>

                <div className="metric-card info">
                    <div className="metric-header">
                        <span className="metric-icon">‚è±Ô∏è</span>
                        <h3>Âπ≥ÂùáÊôÇÈñì</h3>
                    </div>
                    <div className="metric-value">
                        {(metrics.averageHandoverTime / 1000).toFixed(1)}s
                    </div>
                    <div className="metric-trend down">
                        <span className="trend-icon">‚Üò</span>
                        <span>-5% ÊÄßËÉΩÊèêÂçá</span>
                    </div>
                </div>

                <div className="metric-card warning">
                    <div className="metric-header">
                        <span className="metric-icon">üéØ</span>
                        <h3>È†êÊ∏¨Ê∫ñÁ¢∫Áéá</h3>
                    </div>
                    <div className="metric-value">
                        {metrics.predictionAccuracy.toFixed(1)}%
                    </div>
                    <div className="metric-trend up">
                        <span className="trend-icon">‚Üó</span>
                        <span>{useRealData ? 'IEEE INFOCOM 2024' : '+2.3% Ê∫ñÁ¢∫ÁéáÊèêÂçá'}</span>
                    </div>
                </div>

                <div className="metric-card active">
                    <div className="metric-header">
                        <span className="metric-icon">üîÑ</span>
                        <h3>ÈÄ≤Ë°å‰∏≠</h3>
                    </div>
                    <div className="metric-value">
                        {metrics.currentActiveHandovers}
                    </div>
                    <div className="metric-description">Áï∂ÂâçÊèõÊâã‰∏≠</div>
                </div>

                <div className="metric-card error">
                    <div className="metric-header">
                        <span className="metric-icon">‚ùå</span>
                        <h3>Â§±ÊïóÊ¨°Êï∏</h3>
                    </div>
                    <div className="metric-value">
                        {metrics.failedHandovers}
                    </div>
                    <div className="metric-description">ÈúÄË¶ÅÈóúÊ≥®</div>
                </div>
            </div>

            {/* ÊÄßËÉΩÂúñË°®ÂçÄÂüü */}
            <div className="charts-section">
                <div className="chart-container">
                    <h3>üìà ÊèõÊâãÊàêÂäüÁéáË∂®Âã¢</h3>
                    <div className="chart-placeholder">
                        <div className="chart-line">
                            {Array.from({ length: 10 }, (_, i) => (
                                <div
                                    key={i}
                                    className="chart-point"
                                    style={{
                                        left: `${i * 10}%`,
                                        bottom: `${80 + Math.random() * 15}%`,
                                        backgroundColor: '#52c41a',
                                    }}
                                />
                            ))}
                        </div>
                        <div className="chart-info">
                            <span>ÁõÆÊ®ô: 95%</span>
                            <span>
                                Áï∂Ââç: {metrics.handoverSuccessRate.toFixed(1)}%
                            </span>
                        </div>
                    </div>
                </div>

                <div className="chart-container">
                    <h3>‚è±Ô∏è ÊèõÊâãÊôÇÈñìÂàÜ‰Ωà</h3>
                    <div className="chart-placeholder">
                        <div className="histogram">
                            {Array.from({ length: 8 }, (_, i) => (
                                <div
                                    key={i}
                                    className="histogram-bar"
                                    style={{
                                        height: `${30 + Math.random() * 60}%`,
                                        backgroundColor: `hsl(${
                                            200 + i * 10
                                        }, 70%, 50%)`,
                                    }}
                                />
                            ))}
                        </div>
                        <div className="chart-labels">
                            <span>0-1s</span>
                            <span>1-2s</span>
                            <span>2-3s</span>
                            <span>3-4s</span>
                            <span>4-5s</span>
                            <span>5-6s</span>
                            <span>6-7s</span>
                            <span>7s+</span>
                        </div>
                    </div>
                </div>
            </div>

            {/* ÊúÄËøë‰∫ã‰ª∂ÂàóË°® - Êï¥ÂêàÁúüÂØ¶Êï∏Êìö */}
            <div className="events-section">
                <h3>üìã ÊúÄËøëÊèõÊâã‰∫ã‰ª∂</h3>
                
                {/* ÁúüÂØ¶ÈÄ£Êé•ÁãÄÊÖãÊ¶ÇË¶Ω */}
                {useRealData && realConnectionData.connections.size > 0 && (
                    <div className="real-connections-overview" style={{
                        marginBottom: '16px',
                        padding: '12px',
                        backgroundColor: 'rgba(23, 162, 184, 0.1)',
                        borderRadius: '8px',
                        border: '1px solid rgba(23, 162, 184, 0.3)'
                    }}>
                        <h4 style={{ margin: '0 0 8px 0', color: '#17a2b8' }}>üêà Áï∂ÂâçÁúüÂØ¶ÈÄ£Êé•ÁãÄÊÖã</h4>
                        <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '8px' }}>
                            {Array.from(realConnectionData.connections.entries()).slice(0, 6).map(([ueId, conn]) => {
                                const handover = realConnectionData.handovers.get(ueId)
                                return (
                                    <div key={ueId} style={{
                                        padding: '8px',
                                        backgroundColor: 'rgba(255, 255, 255, 0.05)',
                                        borderRadius: '4px',
                                        fontSize: '12px'
                                    }}>
                                        <div style={{ fontWeight: 'bold', marginBottom: '4px' }}>{ueId}</div>
                                        <div>Ë°õÊòü: {conn.current_satellite_id}</div>
                                        <div>‰ø°Ëôü: {conn.signal_quality.toFixed(1)}dBm</div>
                                        <div style={{ color: conn.status === 'connected' ? '#52c41a' : '#ff4d4f' }}>
                                            {conn.status === 'connected' ? '‚úÖ Â∑≤ÈÄ£Êé•' : 
                                             conn.status === 'handover_preparing' ? 'üîÑ Ê∫ñÂÇôÊèõÊâã' :
                                             conn.status === 'handover_executing' ? '‚ö° ÊèõÊâã‰∏≠' : '‚ùå Êú™ÈÄ£Êé•'}
                                        </div>
                                        {handover && handover.handover_status !== 'idle' && (
                                            <div style={{ color: '#1890ff', fontSize: '11px', marginTop: '2px' }}>
                                                ÊèõÊâã: {handover.handover_status}
                                                {handover.prediction_confidence && (
                                                    <span> ({(handover.prediction_confidence * 100).toFixed(0)}%)</span>
                                                )}
                                            </div>
                                        )}
                                    </div>
                                )
                            })}
                        </div>
                    </div>
                )}
                
                <div className="events-table">
                    <div className="events-header">
                        <span>ÊôÇÈñì</span>
                        <span>UAV</span>
                        <span>ÂæûË°õÊòü</span>
                        <span>Âà∞Ë°õÊòü</span>
                        <span>ÊåÅÁ∫åÊôÇÈñì</span>
                        <span>ÁãÄÊÖã</span>
                        <span>ÂéüÂõ†</span>
                    </div>
                    <div className="events-list">
                        {recentEvents.slice(0, 10).map((event) => (
                            <div key={event.id} className="event-row">
                                <span className="event-time">
                                    {new Date(
                                        event.timestamp
                                    ).toLocaleTimeString()}
                                </span>
                                <span className="event-uav">{event.uavId}</span>
                                <span className="event-from">
                                    {event.fromSatellite}
                                </span>
                                <span className="event-to">
                                    {event.toSatellite}
                                </span>
                                <span className="event-duration">
                                    {(event.duration / 1000).toFixed(1)}s
                                </span>
                                <span
                                    className="event-status"
                                    style={{
                                        color: getStatusColor(event.status),
                                    }}
                                >
                                    {event.status === 'success'
                                        ? '‚úÖ'
                                        : event.status === 'failed'
                                        ? '‚ùå'
                                        : 'üîÑ'}
                                    {event.status}
                                </span>
                                <span className="event-reason">
                                    {event.reason}
                                </span>
                            </div>
                        ))}
                    </div>
                </div>
            </div>

            {/* È†êÊ∏¨Ê∫ñÁ¢∫ÁéáÂàÜÊûê */}
            <div className="accuracy-section">
                <h3>üéØ È†êÊ∏¨Ê∫ñÁ¢∫ÁéáÂàÜÊûê</h3>
                <div className="accuracy-grid">
                    <div className="accuracy-summary">
                        <div className="accuracy-metric">
                            <span className="accuracy-label">Êï¥È´îÊ∫ñÁ¢∫Áéá</span>
                            <span className="accuracy-value">
                                {metrics.predictionAccuracy.toFixed(1)}%
                            </span>
                        </div>
                        <div className="accuracy-metric">
                            <span className="accuracy-label">Âπ≥ÂùáÈ†êÊ∏¨ÊôÇÈñì</span>
                            <span className="accuracy-value">
                                {metrics.averagePredictionTime.toFixed(0)}ms
                            </span>
                        </div>
                        <div className="accuracy-metric">
                            <span className="accuracy-label">QoS ÂΩ±Èüø</span>
                            <span className="accuracy-value">
                                {metrics.qosImpact.toFixed(1)}%
                            </span>
                        </div>
                    </div>

                    <div className="accuracy-history">
                        {accuracyHistory.slice(0, 5).map((data, index) => (
                            <div key={index} className="accuracy-item">
                                <span className="accuracy-time">
                                    {data.timeWindow}
                                </span>
                                <div className="accuracy-bar">
                                    <div
                                        className="accuracy-fill"
                                        style={{
                                            width: `${data.accuracy}%`,
                                            backgroundColor: `hsl(${
                                                data.accuracy * 1.2
                                            }, 70%, 50%)`,
                                        }}
                                    />
                                </div>
                                <span className="accuracy-percent">
                                    {data.accuracy.toFixed(0)}%
                                </span>
                            </div>
                        ))}
                    </div>
                </div>
            </div>

            {/* ÈåØË™§ÂíåË≠¶ÂëäÁãÄÊÖã */}
            {error && (
                <div className="error-section" style={{
                    padding: '16px',
                    backgroundColor: 'rgba(245, 34, 45, 0.1)',
                    borderRadius: '8px',
                    border: '1px solid rgba(245, 34, 45, 0.3)',
                    marginBottom: '24px'
                }}>
                    <h3 style={{ color: '#f5222d', margin: '0 0 8px 0' }}>‚ö†Ô∏è Êï∏ÊìöÁç≤ÂèñÈåØË™§</h3>
                    <p style={{ margin: '0', color: '#f5222d' }}>{error}</p>
                    <p style={{ margin: '8px 0 0 0', fontSize: '14px', color: '#666' }}>
                        Á≥ªÁµ±Â∑≤Ëá™ÂãïÂàáÊèõËá≥Ê®°Êì¨Êï∏ÊìöÊ®°ÂºèÔºåË´ãÊ™¢Êü• NetStack ÈÄ£Êé•ÁãÄÊÖã„ÄÇ
                    </p>
                </div>
            )}
            
            {/* ÊÄßËÉΩÂª∫Ë≠∞ - Âü∫ÊñºÁúüÂØ¶Êï∏ÊìöÁöÑÊô∫ËÉΩÂª∫Ë≠∞ */}
            <div className="recommendations-section">
                <h3>üí° ÊÄßËÉΩÂÑ™ÂåñÂª∫Ë≠∞</h3>
                <div className="recommendations-list">
                    {useRealData && metrics.handoverSuccessRate < 90 && (
                        <div className="recommendation-item high">
                            <span className="recommendation-priority">È´ò</span>
                            <span className="recommendation-text">
                                ÊèõÊâãÊàêÂäüÁéá {metrics.handoverSuccessRate.toFixed(1)}% ‰ΩéÊñºÁõÆÊ®ô 90%ÔºåÂª∫Ë≠∞Ê™¢Êü•‰ø°ËôüÈñæÂÄºÂèÉÊï∏
                            </span>
                        </div>
                    )}
                    {useRealData && metrics.predictionAccuracy < 85 && (
                        <div className="recommendation-item medium">
                            <span className="recommendation-priority">‰∏≠</span>
                            <span className="recommendation-text">
                                IEEE INFOCOM 2024 È†êÊ∏¨Ê∫ñÁ¢∫Áéá {metrics.predictionAccuracy.toFixed(1)}% ÂèØÈÄ≤‰∏ÄÊ≠•ÂÑ™Âåñ
                            </span>
                        </div>
                    )}
                    {useRealData && metrics.currentActiveHandovers > 3 && (
                        <div className="recommendation-item medium">
                            <span className="recommendation-priority">‰∏≠</span>
                            <span className="recommendation-text">
                                Áï∂ÂâçÊúâ {metrics.currentActiveHandovers} ÂÄãÊ¥ªË∫çÊèõÊâãÔºåÂèØËÉΩÈúÄË¶ÅË™øÊï¥ÊèõÊâãÁ≠ñÁï•
                            </span>
                        </div>
                    )}
                    {realConnectionData.connections.size > 0 && (
                        Array.from(realConnectionData.connections.values())
                            .filter(conn => conn.signal_quality < -85)
                            .length > 0 && (
                            <div className="recommendation-item high">
                                <span className="recommendation-priority">È´ò</span>
                                <span className="recommendation-text">
                                    Ê™¢Ê∏¨Âà∞ {Array.from(realConnectionData.connections.values()).filter(conn => conn.signal_quality < -85).length} ÂÄãÈÄ£Êé•‰ø°ËôüË≥™Èáè‰ΩéÊñº -85dBmÔºåÂª∫Ë≠∞Á´ãÂç≥ÊèõÊâã
                                </span>
                            </div>
                        )
                    )}
                    {!useRealData && (
                        <>
                            <div className="recommendation-item high">
                                <span className="recommendation-priority">È´ò</span>
                                <span className="recommendation-text">
                                    Ê™¢Ê∏¨Âà∞ÊèõÊâãÂ§±ÊïóÁéáÁï•È´òÔºåÂª∫Ë≠∞Ë™øÊï¥‰ø°ËôüÈñæÂÄºÂèÉÊï∏
                                </span>
                            </div>
                            <div className="recommendation-item medium">
                                <span className="recommendation-priority">‰∏≠</span>
                                <span className="recommendation-text">
                                    È†êÊ∏¨ÁÆóÊ≥ïÂèØÈÄ≤‰∏ÄÊ≠•ÂÑ™ÂåñÔºåËÄÉÊÖÆÂ¢ûÂä†Áí∞Â¢ÉÂõ†Â≠êÊ¨äÈáç
                                </span>
                            </div>
                            <div className="recommendation-item low">
                                <span className="recommendation-priority">‰Ωé</span>
                                <span className="recommendation-text">
                                    Âª∫Ë≠∞Â¢ûÂä†Êõ¥Â§öÂÄôÈÅ∏Ë°õÊòü‰ª•ÊèêÈ´òÊèõÊâãÊàêÂäüÁéá
                                </span>
                            </div>
                        </>
                    )}
                </div>
            </div>
        </div>
    )
}

export default HandoverPerformanceDashboard
