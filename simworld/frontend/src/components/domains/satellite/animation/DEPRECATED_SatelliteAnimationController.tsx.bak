/**
 * âš ï¸âš ï¸âš ï¸ å·²å»¢æ£„ - è«‹å‹¿ä½¿ç”¨ âš ï¸âš ï¸âš ï¸
 * DEPRECATED - DO NOT USE
 * 
 * æ­¤æª”æ¡ˆå·²è¢« DynamicSatelliteRenderer å–ä»£
 * ä¿ç•™åƒ…ä¾›åƒè€ƒå’Œæ­·å²è¨˜éŒ„
 * 
 * è«‹ä½¿ç”¨: src/components/domains/satellite/visualization/DynamicSatelliteRenderer.tsx
 * 
 * ===== åŸå§‹èªªæ˜ =====
 * Phase 2: è¡›æ˜Ÿè»Œè·¡å‹•ç•«æ§åˆ¶å™¨
 *
 * åŸºæ–¼ Phase 0 é è¨ˆç®—æ•¸æ“šå¯¦ç¾å¹³æ»‘çš„è¡›æ˜Ÿå‹•ç•«
 * æ”¯æ´ 60 å€åŠ é€Ÿã€è·é›¢ç¸®æ”¾å’Œæ™‚é–“è»¸æ§åˆ¶
 */

import React, { useRef, useEffect, useState, useCallback } from 'react'
import { useFrame } from '@react-three/fiber'
// import * as THREE from 'three'
import {
    PrecomputedOrbitService,
    AnimationConfig,
} from '../../../../services/PrecomputedOrbitService'
import type {
    OrbitData,
    SatelliteTrajectory,
    HandoverEvent,
} from '../../../../types/satellite'

export interface SatelliteAnimationControllerProps {
    enabled: boolean
    location: string
    constellation: 'starlink' | 'oneweb'
    animationConfig: AnimationConfig
    onHandoverEvent?: (event: HandoverEvent) => void
    onSatellitePositions?: (
        positions: Map<string, [number, number, number]>
    ) => void
    // ä¿®å¾©ï¼šä½¿ç”¨çµ±ä¸€çš„è¡›æ˜Ÿæ•¸æ“šæº
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    unifiedSatellites?: any[]
    children?: React.ReactNode
}

export interface TimelineControl {
    isPlaying: boolean
    currentTime: number
    totalDuration: number
    speed: number
    onPlay: () => void
    onPause: () => void
    onSeek: (time: number) => void
    onSpeedChange: (speed: number) => void
}

interface PrecomputedSatellite {
    norad_id: string
    name: string
    trajectory: SatelliteTrajectory
    handoverEvents: HandoverEvent[]
    isVisible: boolean
    currentPosition: [number, number, number]
    currentVelocity: [number, number, number]
}

export const SatelliteAnimationController: React.FC<
    SatelliteAnimationControllerProps
> = ({
    enabled,
    location,
    constellation,
    animationConfig,
    onHandoverEvent,
    onSatellitePositions,
    unifiedSatellites = [],
    children,
}) => {
    const [orbitService] = useState(() => new PrecomputedOrbitService())
    const [precomputedData, _setPrecomputedData] = useState<OrbitData | null>(
        null
    )
    const [satellites, setSatellites] = useState<
        Map<string, PrecomputedSatellite>
    >(new Map())
    const [timelineControl, setTimelineControl] = useState<TimelineControl>({
        isPlaying: true,
        currentTime: 0,
        totalDuration: 21600, // 6 å°æ™‚ (ç§’)
        speed: animationConfig.acceleration,
        onPlay: () =>
            setTimelineControl((prev) => ({ ...prev, isPlaying: true })),
        onPause: () =>
            setTimelineControl((prev) => ({ ...prev, isPlaying: false })),
        onSeek: (time: number) =>
            setTimelineControl((prev) => ({ ...prev, currentTime: time })),
        onSpeedChange: (speed: number) =>
            setTimelineControl((prev) => ({ ...prev, speed })),
    })

    const animationStartTime = useRef<number>(Date.now())
    const lastHandoverCheck = useRef<number>(0)

    // åŒæ­¥å‹•ç•«é…ç½®çš„é€Ÿåº¦åˆ°æ™‚é–“è»¸æ§åˆ¶
    useEffect(() => {
        setTimelineControl(prev => ({
            ...prev,
            speed: animationConfig.acceleration
        }))
    }, [animationConfig.acceleration])

    // ä¿®å¾©ï¼šå¾çµ±ä¸€è¡›æ˜Ÿæ•¸æ“šåˆå§‹åŒ–
    const initializeSatellitesFromUnified = useCallback(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (unifiedSats: any[]) => {
            const satelliteMap = new Map<string, PrecomputedSatellite>()

            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            unifiedSats.forEach((sat: any) => {
                // å°‡çµ±ä¸€æ•¸æ“šè½‰æ›ç‚ºå‹•ç•«æ§åˆ¶å™¨æ ¼å¼
                const satellite: PrecomputedSatellite = {
                    norad_id:
                        sat.norad_id?.toString() ||
                        sat.id?.toString() ||
                        `${constellation}-${satelliteMap.size}`,
                    name:
                        sat.name ||
                        `${constellation.toUpperCase()}-${
                            sat.norad_id || sat.id
                        }`,
                    // æ·»åŠ å¿…éœ€çš„trajectoryå­—æ®µä»¥é¿å…undefinedéŒ¯èª¤
                    // ğŸš€ ç°¡åŒ–ç‰ˆçœŸå¯¦è»Œè·¡ï¼šåŸºæ–¼ç•¶å‰çœŸå¯¦æ•¸æ“šç”Ÿæˆå‹•æ…‹è»Œé“
                    trajectory: (() => {
                        const timePoints: number[] = []
                        const positions: [number, number, number][] = []
                        const velocities: [number, number, number][] = []
                        
                        // åŸºæ–¼çœŸå¯¦è¡›æ˜Ÿæ•¸æ“šçš„åŸºç¤å€¼
                        const baseElevation = sat.elevation_deg || 45
                        const baseAzimuth = sat.azimuth_deg || 180  
                        const baseDistance = sat.distance_km || 1000
                        
                        // ç”Ÿæˆ10åˆ†é˜è»Œè·¡ (æ¯30ç§’ä¸€é»ï¼Œå…±21å€‹é»)
                        for (let t = 0; t <= 600; t += 30) {
                            timePoints.push(t)
                            
                            // è»Œé“å‹•ç•«åƒæ•¸ (åŸºæ–¼çœŸå¯¦LEOè»Œé“ç‰¹æ€§)
                            const progress = t / 600
                            const elevationChange = Math.sin(progress * Math.PI) * 8  // Â±8åº¦ä»°è§’è®ŠåŒ–
                            const azimuthChange = progress * 45  // 45åº¦æ–¹ä½è§’è®ŠåŒ–
                            const distanceChange = Math.sin(progress * Math.PI * 2) * 50 // Â±50kmè·é›¢æŒ¯ç›ª
                            
                            const currentElevation = Math.max(5, baseElevation + elevationChange)
                            const currentAzimuth = (baseAzimuth + azimuthChange) % 360
                            const currentDistance = baseDistance + distanceChange
                            
                            // è½‰æ›ç‚º3Dåº§æ¨™ (ä½¿ç”¨çœŸå¯¦çš„å¤©çƒåº§æ¨™è½‰æ›)
                            const elevRad = (currentElevation * Math.PI) / 180
                            const azimRad = (currentAzimuth * Math.PI) / 180
                            const scaledDist = currentDistance / 1000 * 0.8
                            
                            const x = scaledDist * Math.cos(elevRad) * Math.sin(azimRad)
                            const y = scaledDist * Math.sin(elevRad)
                            const z = scaledDist * Math.cos(elevRad) * Math.cos(azimRad)
                            
                            positions.push([x, y, z])
                            
                            // LEOè»Œé“é€Ÿåº¦å‘é‡ (ç´„7.8km/s)
                            const orbitalSpeed = 7.8 * 0.001 // ç¸®æ”¾åˆ°3Då ´æ™¯
                            velocities.push([
                                orbitalSpeed * Math.cos(azimRad),
                                orbitalSpeed * 0.1, // è¼•å¾®å‚ç›´åˆ†é‡
                                -orbitalSpeed * Math.sin(azimRad)
                            ])
                        }
                        
                        return {
                            timePoints,
                            positions,
                            velocities,
                            visibilityWindows: [{ start: 0, end: 21600 }] // 6å°æ™‚å¯è¦‹çª—å£ï¼Œèˆ‡ç¸½æ™‚é•·åŒ¹é…
                        }
                    })(),
                    handoverEvents: [], // ç©ºçš„æ›æ‰‹äº‹ä»¶åˆ—è¡¨
                    isVisible: sat.isVisible !== false,
                    currentPosition: [0, 0, 0],
                    currentVelocity: [0, 0, 0]
                }

                satelliteMap.set(satellite.norad_id, satellite)
            })

            setSatellites(satelliteMap)
            console.log(
                `ğŸš€ SatelliteAnimationController: åˆå§‹åŒ– ${satelliteMap.size} é¡† ${constellation.toUpperCase()} è¡›æ˜Ÿ - ç°¡åŒ–ç‰ˆçœŸå¯¦è»Œè·¡å‹•ç•«`
            )
            console.log(`   ğŸ“Š æ¯é¡†è¡›æ˜Ÿæœ‰ 21 å€‹è»Œè·¡é» (10åˆ†é˜, 30ç§’é–“éš”)`)
            console.log(`   ğŸ¯ åŸºæ–¼çœŸå¯¦ä»°è§’ã€æ–¹ä½è§’ã€è·é›¢æ•¸æ“š`)
            
            // é¡¯ç¤ºé¦–é¡†è¡›æ˜Ÿçš„è»Œè·¡ä¿¡æ¯ä½œç‚ºç¤ºä¾‹
            const firstSat = Array.from(satelliteMap.values())[0]
            if (firstSat) {
                const trajectory = firstSat.trajectory
                console.log(`   ğŸ“ ç¤ºä¾‹è»Œè·¡ (${firstSat.name}):`)
                console.log(`     è»Œè·¡é»æ•¸: ${trajectory.timePoints.length}`)
                console.log(`     æ™‚é–“ç¯„åœ: ${trajectory.timePoints[0]}s - ${trajectory.timePoints[trajectory.timePoints.length-1]}s`)
                console.log(`     ä½ç½®è®ŠåŒ–: [${trajectory.positions[0].map(p => p.toFixed(2)).join(', ')}] â†’ [${trajectory.positions[trajectory.positions.length-1].map(p => p.toFixed(2)).join(', ')}]`)
            }
        },
        [constellation]
    )

    // ä¿®å¾©ï¼šå„ªå…ˆä½¿ç”¨çµ±ä¸€çš„è¡›æ˜Ÿæ•¸æ“šï¼Œå›é€€åˆ°é è¨ˆç®—æ•¸æ“šè¼‰å…¥
    useEffect(() => {
        if (!enabled) return

        // ä¿®å¾©ï¼šå®Œå…¨ä¾è³´çµ±ä¸€çš„è¡›æ˜Ÿæ•¸æ“šï¼Œä¸å†å›é€€åˆ°ç¨ç«‹çš„é è¨ˆç®—æ•¸æ“šè¼‰å…¥
        if (unifiedSatellites && unifiedSatellites.length > 0) {
            // åªåœ¨æ•¸æ“šç•°å¸¸æ™‚è¨˜éŒ„æ—¥èªŒ
            if (unifiedSatellites.length === 0) {
                console.log(
                    `âš ï¸ SatelliteAnimationController: [${constellation.toUpperCase()}] ç„¡è¡›æ˜Ÿæ•¸æ“š`
                )
            } else if (unifiedSatellites.length > 20) {
                console.log(
                    `âš ï¸ SatelliteAnimationController: [${constellation.toUpperCase()}] è¡›æ˜Ÿæ•¸é‡ç•°å¸¸: ${
                        unifiedSatellites.length
                    }é¡†`
                )
            }
            initializeSatellitesFromUnified(unifiedSatellites)
        } else {
            // å¦‚æœæ²’æœ‰çµ±ä¸€æ•¸æ“šï¼Œæ¸…ç©ºè¡›æ˜Ÿé¡¯ç¤º
            console.log(
                `âš ï¸ SatelliteAnimationController: æ²’æœ‰çµ±ä¸€è¡›æ˜Ÿæ•¸æ“š [${constellation.toUpperCase()}]ï¼Œæ¸…ç©ºé¡¯ç¤º`
            )
            setSatellites(new Map())
        }
    }, [
        enabled,
        location,
        constellation,
        unifiedSatellites,
        orbitService,
        initializeSatellitesFromUnified,
    ])

    // åˆå§‹åŒ–è¡›æ˜Ÿæ•¸æ“šï¼ˆé è¨ˆç®—æ•¸æ“šï¼‰
    const _initializeSatellites = useCallback((data: OrbitData) => {
        const satelliteMap = new Map<string, PrecomputedSatellite>()

        // å¾é è¨ˆç®—æ•¸æ“šä¸­æå–è¡›æ˜Ÿè»Œè·¡
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        data.filtered_satellites?.forEach((sat: any) => {
            const satellite: PrecomputedSatellite = {
                norad_id: sat.norad_id,
                name: sat.name || `SAT-${sat.norad_id}`,
                trajectory: {
                    timePoints: [],
                    positions: [],
                    velocities: [],
                    visibilityWindows: [],
                },
                handoverEvents: [],
                isVisible: false,
                currentPosition: [0, 0, 0],
                currentVelocity: [0, 0, 0],
            }

            satelliteMap.set(sat.norad_id, satellite)
        })

        setSatellites(satelliteMap)
    }, [])

    // æ’å€¼è¨ˆç®—è¡›æ˜Ÿä½ç½®
    const interpolatePosition = useCallback(
        (
            trajectory: SatelliteTrajectory,
            currentTime: number,
            recursionDepth: number = 0
        ): {
            position: [number, number, number]
            velocity: [number, number, number]
            isVisible: boolean
        } => {
            // é˜²æ­¢ç„¡é™éæ­¸
            if (recursionDepth > 5) {
                console.warn(
                    'interpolatePosition: é”åˆ°æœ€å¤§éæ­¸æ·±åº¦ï¼Œè¿”å›é è¨­å€¼'
                )
                return {
                    position: [0, -1000, 0],
                    velocity: [0, 0, 0],
                    isVisible: false,
                }
            }

            if (!trajectory || !trajectory.timePoints || trajectory.timePoints.length === 0) {
                return {
                    position: [0, -1000, 0], // éš±è—åœ¨åœ°ä¸‹
                    velocity: [0, 0, 0],
                    isVisible: false,
                }
            }

            // ä¿®å¾©ï¼šå°æ–¼çµ±ä¸€æ•¸æ“šçš„è¡›æ˜Ÿï¼ˆåªæœ‰ä¸€å€‹æ™‚é–“é»ï¼‰ï¼Œç›´æ¥è¿”å›å›ºå®šä½ç½®
            if (
                trajectory.timePoints.length === 1 &&
                trajectory.timePoints[0] === 0
            ) {
                return {
                    position: trajectory.positions[0] || [0, -1000, 0],
                    velocity: trajectory.velocities[0] || [0, 0, 0],
                    isVisible:
                        trajectory.visibilityWindows.some(
                            (window) =>
                                currentTime >= window.start &&
                                currentTime <= window.end
                        ) || true, // çµ±ä¸€æ•¸æ“šçš„è¡›æ˜Ÿé è¨­å¯è¦‹
                }
            }

            // æ‰¾åˆ°ç•¶å‰æ™‚é–“å°æ‡‰çš„è»Œè·¡é»
            const timeIndex = trajectory.timePoints.findIndex(
                (t) => t > currentTime
            )

            if (timeIndex === -1) {
                // è¶…å‡ºè»Œè·¡ç¯„åœï¼Œä½¿ç”¨æœ€å¾Œä¸€å€‹é»è€Œééæ­¸
                const lastIndex = trajectory.timePoints.length - 1
                const maxTime = trajectory.timePoints[lastIndex]

                // å¦‚æœæ™‚é–“é»ç„¡æ•ˆï¼Œç›´æ¥è¿”å›æœ€å¾Œä¸€å€‹ä½ç½®
                if (!maxTime || maxTime <= 0) {
                    return {
                        position: trajectory.positions[lastIndex] || [
                            0, -1000, 0,
                        ],
                        velocity: trajectory.velocities[lastIndex] || [0, 0, 0],
                        isVisible: false,
                    }
                }

                // å¾ªç’°åˆ°è»Œè·¡é–‹å§‹ï¼ˆä½†é™åˆ¶éæ­¸æ·±åº¦ï¼‰
                const cycleTime = currentTime % maxTime
                return interpolatePosition(
                    trajectory,
                    cycleTime,
                    recursionDepth + 1
                )
            }

            if (timeIndex === 0) {
                // åœ¨è»Œè·¡é–‹å§‹ä¹‹å‰ï¼Œä½¿ç”¨ç¬¬ä¸€å€‹é»
                return {
                    position: trajectory.positions[0] || [0, -1000, 0],
                    velocity: trajectory.velocities[0] || [0, 0, 0],
                    isVisible: trajectory.visibilityWindows.some(
                        (window) =>
                            currentTime >= window.start &&
                            currentTime <= window.end
                    ),
                }
            }

            // ç·šæ€§æ’å€¼
            const t1 = trajectory.timePoints[timeIndex - 1]
            const t2 = trajectory.timePoints[timeIndex]
            const factor = (currentTime - t1) / (t2 - t1)

            const pos1 = trajectory.positions[timeIndex - 1] || [0, 0, 0]
            const pos2 = trajectory.positions[timeIndex] || [0, 0, 0]
            const vel1 = trajectory.velocities[timeIndex - 1] || [0, 0, 0]
            const vel2 = trajectory.velocities[timeIndex] || [0, 0, 0]

            const interpolatedPosition: [number, number, number] = [
                pos1[0] + (pos2[0] - pos1[0]) * factor,
                pos1[1] + (pos2[1] - pos1[1]) * factor,
                pos1[2] + (pos2[2] - pos1[2]) * factor,
            ]

            const interpolatedVelocity: [number, number, number] = [
                vel1[0] + (vel2[0] - vel1[0]) * factor,
                vel1[1] + (vel2[1] - vel1[1]) * factor,
                vel1[2] + (vel2[2] - vel1[2]) * factor,
            ]

            // æ‡‰ç”¨è·é›¢ç¸®æ”¾
            const scaledPosition: [number, number, number] = [
                interpolatedPosition[0] * animationConfig.distanceScale,
                interpolatedPosition[1] * animationConfig.distanceScale,
                interpolatedPosition[2] * animationConfig.distanceScale,
            ]

            return {
                position: scaledPosition,
                velocity: interpolatedVelocity,
                isVisible: trajectory.visibilityWindows.some(
                    (window) =>
                        currentTime >= window.start && currentTime <= window.end
                ),
            }
        },
        [animationConfig.distanceScale]
    )

    // å‹•ç•«æ›´æ–°å¾ªç’°
    useFrame((state, delta) => {
        if (!enabled || !timelineControl.isPlaying || satellites.size === 0)
            return

        // æ›´æ–°å‹•ç•«æ™‚é–“
        const newTime =
            timelineControl.currentTime + delta * timelineControl.speed

        if (newTime > timelineControl.totalDuration) {
            // å¾ªç’°æ’­æ”¾
            setTimelineControl((prev) => ({ ...prev, currentTime: 0 }))
            animationStartTime.current = Date.now()
            return
        }

        setTimelineControl((prev) => ({ ...prev, currentTime: newTime }))

        // æ›´æ–°æ‰€æœ‰è¡›æ˜Ÿä½ç½®
        const updatedSatellites = new Map(satellites)
        const currentPositions = new Map<string, [number, number, number]>()

        updatedSatellites.forEach((satellite, noradId) => {
            const { position, velocity, isVisible } = interpolatePosition(
                satellite.trajectory,
                newTime
            )

            satellite.currentPosition = position
            satellite.currentVelocity = velocity
            satellite.isVisible = isVisible

            if (isVisible) {
                currentPositions.set(noradId, position)
            }
        })

        setSatellites(updatedSatellites)

        // é€šçŸ¥çˆ¶çµ„ä»¶è¡›æ˜Ÿä½ç½®æ›´æ–°
        if (onSatellitePositions) {
            onSatellitePositions(currentPositions)
        }

        // æª¢æŸ¥æ›æ‰‹äº‹ä»¶ (æ¯ç§’æª¢æŸ¥ä¸€æ¬¡)
        if (newTime - lastHandoverCheck.current >= 1.0) {
            checkHandoverEvents(newTime)
            lastHandoverCheck.current = newTime
        }
    })

    // æª¢æŸ¥æ›æ‰‹äº‹ä»¶
    const checkHandoverEvents = useCallback(
        (currentTime: number) => {
            satellites.forEach((satellite) => {
                satellite.handoverEvents.forEach((event) => {
                    if (
                        Math.abs(event.timestamp - currentTime) < 0.5 &&
                        onHandoverEvent
                    ) {
                        onHandoverEvent(event)
                    }
                })
            })
        },
        [satellites, onHandoverEvent]
    )

    // æ¸²æŸ“è¡›æ˜Ÿ
    const renderSatellites = () => {
        const visibleSatellites = Array.from(satellites.values()).filter(
            (sat) => sat.isVisible
        )

        return visibleSatellites.map((satellite) => (
            <group
                key={satellite.norad_id}
                position={satellite.currentPosition}
            >
                {/* è¡›æ˜Ÿæ¨¡å‹ */}
                <mesh>
                    <sphereGeometry args={[2, 8, 8]} />
                    <meshBasicMaterial color="#00ff00" />
                </mesh>

                {/* è¡›æ˜Ÿæ¨™ç±¤ */}
                <group position={[0, 5, 0]}>
                    <mesh>
                        <planeGeometry args={[20, 4]} />
                        <meshBasicMaterial
                            color="#000000"
                            transparent
                            opacity={0.7}
                        />
                    </mesh>
                    {/* é€™è£¡å¯ä»¥æ·»åŠ  Text çµ„ä»¶é¡¯ç¤ºè¡›æ˜Ÿåç¨± */}
                </group>

                {/* è»Œè·¡ç·š */}
                {animationConfig.smoothing && (
                    <line>
                        <bufferGeometry>
                            <bufferAttribute
                                attach="attributes-position"
                                count={satellite.trajectory.positions.length}
                                array={
                                    new Float32Array(
                                        satellite.trajectory.positions.flat()
                                    )
                                }
                                itemSize={3}
                            />
                        </bufferGeometry>
                        <lineBasicMaterial
                            color="#ffffff"
                            opacity={0.3}
                            transparent
                        />
                    </line>
                )}
            </group>
        ))
    }

    if (!enabled || !precomputedData) {
        return <>{children}</>
    }

    return (
        <group>
            {renderSatellites()}
            {children}
        </group>
    )
}

export default SatelliteAnimationController
