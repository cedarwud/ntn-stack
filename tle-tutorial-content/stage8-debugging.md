# éšæ®µ8ï¼šé™¤éŒ¯å’Œæ•…éšœæ’é™¤

## èª²ç¨‹ç›®æ¨™èˆ‡å­¸ç¿’é‡é»

### å®Œæˆæœ¬éšæ®µå¾Œæ‚¨å°‡èƒ½å¤ ï¼š
- æŒæ¡è¡›æ˜Ÿè»Œé“è¨ˆç®—ç³»çµ±çš„å®Œæ•´é™¤éŒ¯æ–¹æ³•è«–
- å»ºç«‹ç³»çµ±æ€§çš„æ•…éšœè¨ºæ–·å’Œä¿®å¾©æµç¨‹
- å¯¦ç¾è‡ªå‹•åŒ–çš„å•é¡Œæª¢æ¸¬å’Œé è­¦æ©Ÿåˆ¶
- è™•ç†ç”Ÿç”¢ç’°å¢ƒä¸­çš„è¤‡é›œæ•…éšœå ´æ™¯
- å»ºç«‹å®Œæ•´çš„é‹ç¶­å’Œæ•…éšœæ¢å¾©é«”ç³»

### è·æ¥­ç™¼å±•åƒ¹å€¼ï¼š
- å…·å‚™è¤‡é›œç³»çµ±æ•…éšœæ’é™¤çš„å°ˆæ¥­æŠ€èƒ½
- æŒæ¡ç”Ÿç”¢ç´šè»Ÿé«”çš„ç¶­é‹ç¶“é©—
- ç†è§£èˆªå¤ªç³»çµ±çš„é«˜å¯é æ€§è¦æ±‚
- å…·å‚™ç³»çµ±æ¶æ§‹è¨ºæ–·å’Œå„ªåŒ–èƒ½åŠ›

## æ•…éšœåˆ†é¡èˆ‡è¨ºæ–·é«”ç³»

### æ•…éšœåˆ†é¡æ¶æ§‹

**æŒ‰å½±éŸ¿å±¤ç´šåˆ†é¡ï¼š**
```
L1 - ç³»çµ±ç´šæ•…éšœ        â† å®Œå…¨ç„¡æ³•è™•ç†ï¼Œç³»çµ±åœæ©Ÿ
    â†“
L2 - çµ„ä»¶ç´šæ•…éšœ        â† å–®å€‹çµ„ä»¶å¤±æ•ˆï¼Œå½±éŸ¿éƒ¨åˆ†åŠŸèƒ½
    â†“
L3 - æ•¸æ“šç´šæ•…éšœ        â† éƒ¨åˆ†æ•¸æ“šç•°å¸¸ï¼Œè·³éå•é¡Œæ•¸æ“š
    â†“
L4 - ç²¾åº¦ç´šæ•…éšœ        â† è¨ˆç®—ç²¾åº¦ä¸‹é™ï¼Œä½†ä¸å½±éŸ¿åŸºæœ¬åŠŸèƒ½
```

**æŒ‰æ•…éšœåŸå› åˆ†é¡ï¼š**
- **æ•¸æ“šå•é¡Œ** - TLEæ ¼å¼éŒ¯èª¤ã€æ•¸æ“šéæœŸã€ç¼ºå¤±
- **ç®—æ³•å•é¡Œ** - SGP4è¨ˆç®—ç•°å¸¸ã€åº§æ¨™è½‰æ›éŒ¯èª¤
- **ç’°å¢ƒå•é¡Œ** - è¨˜æ†¶é«”ä¸è¶³ã€ä¾è³´ç¼ºå¤±ã€æ¬Šé™å•é¡Œ
- **é…ç½®å•é¡Œ** - åƒæ•¸è¨­ç½®éŒ¯èª¤ã€é–¾å€¼ä¸ç•¶ã€è·¯å¾‘éŒ¯èª¤

### å¸¸è¦‹æ•…éšœç—‡ç‹€å°ç…§è¡¨

**ç—‡ç‹€ â†’ å¯èƒ½åŸå›  â†’ è¨ºæ–·æ–¹æ³•ï¼š**

| ç—‡ç‹€ | å¯èƒ½åŸå›  | è¨ºæ–·æ–¹æ³• | å„ªå…ˆç´š |
|------|----------|----------|--------|
| 8000+è¡›æ˜Ÿâ†’0é¡†å¯è¦‹ | æ™‚é–“åŸºæº–éŒ¯èª¤ | æª¢æŸ¥TLE epoch vs è¨ˆç®—æ™‚é–“ | ğŸ”¥ CRITICAL |
| ä½ç½®èª¤å·®>10km | SGP4å¯¦ç¾éŒ¯èª¤ | èˆ‡skyfieldæ¯”è¼ƒ | ğŸ”¥ HIGH |
| è¨˜æ†¶é«”ä½¿ç”¨çˆ†ç‚¸ | å¿«å–æœªæ¸…ç†/æ‰¹è™•ç†éå¤§ | ç›£æ§è¨˜æ†¶é«”ä½¿ç”¨æ›²ç·š | âš ï¸ MEDIUM |
| è™•ç†é€Ÿåº¦é©Ÿé™ | æ•¸æ“šå“è³ªå·®/å¤§é‡éŒ¯èª¤ | åˆ†æéŒ¯èª¤ç‡çµ±è¨ˆ | âš ï¸ MEDIUM |
| é–“æ­‡æ€§è¨ˆç®—å¤±æ•— | TLEæ•¸æ“šæå£ | é©—è­‰TLEæª¢æŸ¥ç¢¼ | âš ï¸ MEDIUM |

## æ ¸å¿ƒé™¤éŒ¯å·¥å…·å¯¦ç¾

### 1. DiagnosticTool - è¨ºæ–·å·¥å…·

**debugging/diagnostic_tool.py å®Œæ•´å¯¦ç¾ï¼š**
```python
#!/usr/bin/env python3
"""
è¨ºæ–·å·¥å…·
æä¾›ç³»çµ±æ•…éšœçš„è‡ªå‹•è¨ºæ–·å’Œåˆ†æåŠŸèƒ½
"""

import os
import sys
import psutil
import logging
import numpy as np
from typing import Dict, List, Tuple, Optional
from datetime import datetime, timedelta
import traceback
import json

from ..data.parser import TLEData, TLEParser
from ..data.loader import TLEDataLoader
from ..calculation.sgp4_engine import SGP4Calculator
from ..utils.quality_validator import QualityValidator
from ..utils.accuracy_comparator import AccuracyComparator

logger = logging.getLogger(__name__)

class DiagnosticTool:
    """ç³»çµ±è¨ºæ–·å·¥å…·"""
    
    def __init__(self):
        """åˆå§‹åŒ–è¨ºæ–·å·¥å…·"""
        self.diagnostic_results = {}
        self.system_info = self._collect_system_info()
        
    def run_comprehensive_diagnosis(self, 
                                  tle_file_path: Optional[str] = None,
                                  sample_size: int = 10) -> Dict:
        """
        åŸ·è¡Œç¶œåˆç³»çµ±è¨ºæ–·
        
        Args:
            tle_file_path: TLEæª”æ¡ˆè·¯å¾‘ï¼ˆå¯é¸ï¼Œç”¨æ–¼æ¸¬è©¦ï¼‰
            sample_size: æ¨£æœ¬æ¸¬è©¦å¤§å°
            
        Returns:
            Dict: è¨ºæ–·å ±å‘Š
        """
        logger.info("é–‹å§‹ç¶œåˆç³»çµ±è¨ºæ–·...")
        
        diagnosis = {
            'timestamp': datetime.now().isoformat(),
            'system_info': self.system_info,
            'test_results': {},
            'issues_found': [],
            'recommendations': [],
            'overall_health': 'UNKNOWN'
        }
        
        # 1. ç’°å¢ƒè¨ºæ–·
        env_result = self._diagnose_environment()
        diagnosis['test_results']['environment'] = env_result
        
        # 2. ä¾è³´æª¢æŸ¥
        deps_result = self._check_dependencies()
        diagnosis['test_results']['dependencies'] = deps_result
        
        # 3. åŸºç¤åŠŸèƒ½æ¸¬è©¦
        basic_result = self._test_basic_functionality()
        diagnosis['test_results']['basic_functionality'] = basic_result
        
        # 4. å¦‚æœæä¾›äº†TLEæª”æ¡ˆï¼Œé€²è¡Œæ•¸æ“šæ¸¬è©¦
        if tle_file_path and os.path.exists(tle_file_path):
            data_result = self._test_tle_data_processing(tle_file_path, sample_size)
            diagnosis['test_results']['data_processing'] = data_result
            
            # 5. ç²¾åº¦æ¸¬è©¦
            accuracy_result = self._test_accuracy(tle_file_path, sample_size)
            diagnosis['test_results']['accuracy'] = accuracy_result
        
        # 6. æ€§èƒ½åŸºæº–æ¸¬è©¦
        perf_result = self._benchmark_performance()
        diagnosis['test_results']['performance'] = perf_result
        
        # å½™ç¸½å•é¡Œå’Œå»ºè­°
        self._analyze_results(diagnosis)
        
        # å„²å­˜è¨ºæ–·çµæœ
        self.diagnostic_results = diagnosis
        
        logger.info(f"ç³»çµ±è¨ºæ–·å®Œæˆ - æ•´é«”å¥åº·åº¦: {diagnosis['overall_health']}")
        return diagnosis
    
    def _collect_system_info(self) -> Dict:
        """æ”¶é›†ç³»çµ±ä¿¡æ¯"""
        try:
            return {
                'platform': sys.platform,
                'python_version': sys.version,
                'cpu_count': psutil.cpu_count(),
                'memory_total_gb': psutil.virtual_memory().total / (1024**3),
                'memory_available_gb': psutil.virtual_memory().available / (1024**3),
                'disk_free_gb': psutil.disk_usage('.').free / (1024**3),
                'current_directory': os.getcwd()
            }
        except Exception as e:
            logger.error(f"æ”¶é›†ç³»çµ±ä¿¡æ¯å¤±æ•—: {e}")
            return {'error': str(e)}
    
    def _diagnose_environment(self) -> Dict:
        """è¨ºæ–·é‹è¡Œç’°å¢ƒ"""
        issues = []
        status = 'HEALTHY'
        
        try:
            # æª¢æŸ¥Pythonç‰ˆæœ¬
            if sys.version_info < (3, 8):
                issues.append(f"Pythonç‰ˆæœ¬éä½: {sys.version_info}, å»ºè­°3.8+")
                status = 'WARNING'
            
            # æª¢æŸ¥è¨˜æ†¶é«”
            memory = psutil.virtual_memory()
            if memory.available < 2 * 1024**3:  # å°‘æ–¼2GBå¯ç”¨è¨˜æ†¶é«”
                issues.append(f"å¯ç”¨è¨˜æ†¶é«”ä¸è¶³: {memory.available/(1024**3):.1f}GB")
                status = 'WARNING'
            
            # æª¢æŸ¥ç£ç¢Ÿç©ºé–“
            disk = psutil.disk_usage('.')
            if disk.free < 1 * 1024**3:  # å°‘æ–¼1GBç£ç¢Ÿç©ºé–“
                issues.append(f"ç£ç¢Ÿç©ºé–“ä¸è¶³: {disk.free/(1024**3):.1f}GB")
                status = 'WARNING'
            
            # æª¢æŸ¥CPUè² è¼‰
            cpu_percent = psutil.cpu_percent(interval=1)
            if cpu_percent > 90:
                issues.append(f"CPUè² è¼‰éé«˜: {cpu_percent}%")
                status = 'WARNING'
                
        except Exception as e:
            issues.append(f"ç’°å¢ƒè¨ºæ–·å¤±æ•—: {e}")
            status = 'ERROR'
        
        return {
            'status': status,
            'issues': issues,
            'details': self.system_info
        }
    
    def _check_dependencies(self) -> Dict:
        """æª¢æŸ¥ä¾è³´å¥—ä»¶"""
        required_packages = [
            'numpy', 'skyfield', 'astropy', 'pandas', 
            'scipy', 'psutil', 'pytz'
        ]
        
        missing_packages = []
        version_info = {}
        
        for package in required_packages:
            try:
                module = __import__(package)
                if hasattr(module, '__version__'):
                    version_info[package] = module.__version__
                else:
                    version_info[package] = 'unknown'
            except ImportError:
                missing_packages.append(package)
        
        status = 'ERROR' if missing_packages else 'HEALTHY'
        
        return {
            'status': status,
            'missing_packages': missing_packages,
            'installed_versions': version_info,
            'issues': [f"ç¼ºå°‘å¥—ä»¶: {pkg}" for pkg in missing_packages]
        }
    
    def _test_basic_functionality(self) -> Dict:
        """æ¸¬è©¦åŸºç¤åŠŸèƒ½"""
        tests = {}
        overall_status = 'HEALTHY'
        
        # æ¸¬è©¦TLEè§£æå™¨
        try:
            parser = TLEParser()
            test_tle = [
                "ISS (ZARYA)",
                "1 25544U 98067A   25245.12345678  .00002182  00000-0  14829-4 0  9999",
                "2 25544  51.6461 339.7760 0003363  31.3921 328.8071 15.54225995123459"
            ]
            result = parser.parse_tle_group(test_tle)
            tests['tle_parser'] = {
                'status': 'PASSED' if result else 'FAILED',
                'details': 'TLEè§£æå™¨åŸºæœ¬åŠŸèƒ½æ¸¬è©¦'
            }
            if not result:
                overall_status = 'ERROR'
        except Exception as e:
            tests['tle_parser'] = {
                'status': 'FAILED',
                'error': str(e)
            }
            overall_status = 'ERROR'
        
        # æ¸¬è©¦SGP4è¨ˆç®—å™¨
        try:
            calculator = SGP4Calculator()
            if 'tle_parser' in tests and tests['tle_parser']['status'] == 'PASSED':
                # ä½¿ç”¨è§£æçš„TLEæ•¸æ“šæ¸¬è©¦SGP4
                tle_data = TLEData(
                    satellite_number=25544,
                    satellite_name="ISS (ZARYA)",
                    epoch_year=25,
                    epoch_day=245.12345678,
                    mean_motion=15.54225995,
                    eccentricity=0.0003363,
                    inclination=51.6461,
                    raan=339.7760,
                    argument_of_perigee=31.3921,
                    mean_anomaly=328.8071,
                    mean_motion_derivative=0.00002182,
                    mean_motion_second_derivative=0.0,
                    bstar=0.00014829,
                    element_number=999,
                    revolution_number=12345
                )
                
                calc_time = tle_data.get_epoch_datetime()
                result = calculator.calculate_satellite_position(tle_data, calc_time)
                
                tests['sgp4_calculator'] = {
                    'status': 'PASSED' if 'position_eci_km' in result else 'FAILED',
                    'details': 'SGP4è¨ˆç®—å™¨åŸºæœ¬åŠŸèƒ½æ¸¬è©¦'
                }
                if 'position_eci_km' not in result:
                    overall_status = 'ERROR'
            else:
                tests['sgp4_calculator'] = {
                    'status': 'SKIPPED',
                    'reason': 'TLEè§£æå™¨æ¸¬è©¦å¤±æ•—'
                }
        except Exception as e:
            tests['sgp4_calculator'] = {
                'status': 'FAILED',
                'error': str(e)
            }
            overall_status = 'ERROR'
        
        # æ¸¬è©¦å“è³ªé©—è­‰å™¨
        try:
            validator = QualityValidator()
            # ä½¿ç”¨æ¸¬è©¦æ•¸æ“š
            validation_result = validator.validate_calculation_result({
                'position_eci_km': [6800, 0, 0],
                'velocity_eci_kmps': [0, 7.5, 0],
                'calculation_time': datetime.now(),
                'tle_epoch': datetime.now()
            })
            
            tests['quality_validator'] = {
                'status': 'PASSED' if validation_result.is_valid else 'WARNING',
                'details': 'å“è³ªé©—è­‰å™¨åŸºæœ¬åŠŸèƒ½æ¸¬è©¦'
            }
        except Exception as e:
            tests['quality_validator'] = {
                'status': 'FAILED',
                'error': str(e)
            }
            if overall_status == 'HEALTHY':
                overall_status = 'WARNING'
        
        return {
            'status': overall_status,
            'test_results': tests
        }
    
    def _test_tle_data_processing(self, tle_file_path: str, sample_size: int) -> Dict:
        """æ¸¬è©¦TLEæ•¸æ“šè™•ç†"""
        issues = []
        status = 'HEALTHY'
        stats = {}
        
        try:
            # è¼‰å…¥TLEæ•¸æ“š
            loader = TLEDataLoader()
            tle_lines = loader.load_tle_file(tle_file_path)
            
            stats['total_lines'] = len(tle_lines)
            stats['expected_satellites'] = len(tle_lines) // 3
            
            # é©—è­‰æ•¸æ“šæ ¼å¼
            validation_result = loader.validate_tle_data(tle_lines)
            if not validation_result:
                issues.append("TLEæ•¸æ“šæ ¼å¼é©—è­‰å¤±æ•—")
                status = 'ERROR'
            
            # è§£ææ¨£æœ¬æ•¸æ“š
            parser = TLEParser()
            sample_lines = tle_lines[:sample_size * 3]
            parsed_data = parser.parse_tle_file(sample_lines)
            
            stats['sample_size'] = len(parsed_data)
            stats['parse_success_rate'] = len(parsed_data) / sample_size if sample_size > 0 else 0
            
            if stats['parse_success_rate'] < 0.9:
                issues.append(f"TLEè§£ææˆåŠŸç‡éä½: {stats['parse_success_rate']:.1%}")
                status = 'WARNING' if status == 'HEALTHY' else status
            
            # é©—è­‰è§£æçµæœçš„å“è³ª
            validator = QualityValidator()
            validation_issues = 0
            
            for tle_data in parsed_data[:5]:  # æª¢æŸ¥å‰5å€‹
                result = validator.validate_tle_data(tle_data)
                if not result.is_valid:
                    validation_issues += 1
            
            stats['validation_issue_rate'] = validation_issues / min(5, len(parsed_data)) if parsed_data else 1
            
            if stats['validation_issue_rate'] > 0.2:
                issues.append(f"TLEæ•¸æ“šå“è³ªå•é¡Œç‡éé«˜: {stats['validation_issue_rate']:.1%}")
                status = 'WARNING' if status == 'HEALTHY' else status
                
        except Exception as e:
            issues.append(f"TLEæ•¸æ“šè™•ç†æ¸¬è©¦å¤±æ•—: {e}")
            status = 'ERROR'
        
        return {
            'status': status,
            'issues': issues,
            'statistics': stats
        }
    
    def _test_accuracy(self, tle_file_path: str, sample_size: int) -> Dict:
        """æ¸¬è©¦è¨ˆç®—ç²¾åº¦"""
        issues = []
        status = 'HEALTHY'
        accuracy_stats = {}
        
        try:
            # è¼‰å…¥å’Œè§£ææ¸¬è©¦æ•¸æ“š
            loader = TLEDataLoader()
            tle_lines = loader.load_tle_file(tle_file_path)
            
            parser = TLEParser()
            sample_lines = tle_lines[:sample_size * 3]
            parsed_data = parser.parse_tle_file(sample_lines)
            
            if not parsed_data:
                return {
                    'status': 'ERROR',
                    'issues': ['ç„¡æœ‰æ•ˆçš„TLEæ•¸æ“šé€²è¡Œç²¾åº¦æ¸¬è©¦'],
                    'statistics': {}
                }
            
            # é€²è¡ŒSGP4è¨ˆç®—
            calculator = SGP4Calculator()
            comparator = AccuracyComparator()
            
            calculation_results = []
            for tle_data in parsed_data[:3]:  # åªæ¸¬è©¦å‰3å€‹ä»¥ç¯€çœæ™‚é–“
                try:
                    calc_time = tle_data.get_epoch_datetime()
                    result = calculator.calculate_satellite_position(tle_data, calc_time)
                    calculation_results.append(result)
                except Exception as e:
                    logger.warning(f"è·³éè¨ˆç®—å¤±æ•—çš„è¡›æ˜Ÿ: {e}")
            
            if not calculation_results:
                return {
                    'status': 'ERROR',
                    'issues': ['æ‰€æœ‰SGP4è¨ˆç®—éƒ½å¤±æ•—'],
                    'statistics': {}
                }
            
            # ç²¾åº¦æ¯”è¼ƒæ¸¬è©¦
            accuracy_report = comparator.batch_accuracy_analysis(
                parsed_data[:len(calculation_results)], 
                calculation_results
            )
            
            if 'error' in accuracy_report:
                issues.append(f"ç²¾åº¦æ¸¬è©¦å¤±æ•—: {accuracy_report['error']}")
                status = 'ERROR'
            else:
                accuracy_stats = accuracy_report
                
                # æª¢æŸ¥ç²¾åº¦æ¨™æº–
                pos_error = accuracy_report['position_accuracy']['mean_error_km']
                vel_error = accuracy_report['velocity_accuracy']['mean_error_kmps']
                
                if pos_error > 5.0:
                    issues.append(f"ä½ç½®ç²¾åº¦éä½: {pos_error:.3f}km")
                    status = 'ERROR'
                elif pos_error > 1.0:
                    issues.append(f"ä½ç½®ç²¾åº¦è¼ƒä½: {pos_error:.3f}km")
                    status = 'WARNING' if status == 'HEALTHY' else status
                
                if vel_error > 0.05:
                    issues.append(f"é€Ÿåº¦ç²¾åº¦éä½: {vel_error:.5f}km/s")
                    status = 'ERROR'
                elif vel_error > 0.01:
                    issues.append(f"é€Ÿåº¦ç²¾åº¦è¼ƒä½: {vel_error:.5f}km/s")
                    status = 'WARNING' if status == 'HEALTHY' else status
                
        except Exception as e:
            issues.append(f"ç²¾åº¦æ¸¬è©¦å¤±æ•—: {e}")
            status = 'ERROR'
        
        return {
            'status': status,
            'issues': issues,
            'statistics': accuracy_stats
        }
    
    def _benchmark_performance(self) -> Dict:
        """æ€§èƒ½åŸºæº–æ¸¬è©¦"""
        issues = []
        status = 'HEALTHY'
        perf_stats = {}
        
        try:
            # å‰µå»ºæ¸¬è©¦æ•¸æ“š
            test_tle_data = TLEData(
                satellite_number=25544,
                satellite_name="TEST_SAT",
                epoch_year=25,
                epoch_day=245.0,
                mean_motion=15.54,
                eccentricity=0.001,
                inclination=51.6,
                raan=339.8,
                argument_of_perigee=31.4,
                mean_anomaly=328.8,
                mean_motion_derivative=0.0,
                mean_motion_second_derivative=0.0,
                bstar=0.0001,
                element_number=1,
                revolution_number=1000
            )
            
            calculator = SGP4Calculator()
            calc_time = test_tle_data.get_epoch_datetime()
            
            # æ¸¬è©¦å–®æ¬¡è¨ˆç®—æ€§èƒ½
            start_time = datetime.now()
            for _ in range(100):  # è¨ˆç®—100æ¬¡
                result = calculator.calculate_satellite_position(test_tle_data, calc_time)
            single_calc_time = (datetime.now() - start_time).total_seconds()
            
            calculations_per_second = 100 / single_calc_time
            perf_stats['calculations_per_second'] = calculations_per_second
            
            # æ€§èƒ½åŸºæº–æª¢æŸ¥
            if calculations_per_second < 100:
                issues.append(f"è¨ˆç®—æ€§èƒ½éä½: {calculations_per_second:.1f} calc/s")
                status = 'WARNING'
            
            # æ¸¬è©¦è¨˜æ†¶é«”ä½¿ç”¨
            import psutil
            process = psutil.Process()
            memory_before = process.memory_info().rss / (1024**2)  # MB
            
            # åŸ·è¡Œæ‰¹é‡è¨ˆç®—
            batch_results = calculator.calculate_batch_positions(
                [test_tle_data] * 50,
                [calc_time + timedelta(minutes=i) for i in range(10)]
            )
            
            memory_after = process.memory_info().rss / (1024**2)  # MB
            memory_increase = memory_after - memory_before
            
            perf_stats['memory_increase_mb'] = memory_increase
            perf_stats['batch_results_count'] = len(batch_results)
            
            if memory_increase > 500:  # è¨˜æ†¶é«”å¢åŠ è¶…é500MB
                issues.append(f"è¨˜æ†¶é«”ä½¿ç”¨å¢é•·éå¤š: {memory_increase:.1f}MB")
                status = 'WARNING' if status == 'HEALTHY' else status
                
        except Exception as e:
            issues.append(f"æ€§èƒ½æ¸¬è©¦å¤±æ•—: {e}")
            status = 'ERROR'
        
        return {
            'status': status,
            'issues': issues,
            'statistics': perf_stats
        }
    
    def _analyze_results(self, diagnosis: Dict):
        """åˆ†æè¨ºæ–·çµæœä¸¦ç”Ÿæˆå»ºè­°"""
        all_issues = []
        critical_count = 0
        warning_count = 0
        
        # æ”¶é›†æ‰€æœ‰å•é¡Œ
        for test_name, result in diagnosis['test_results'].items():
            if 'issues' in result:
                all_issues.extend(result['issues'])
            
            if result.get('status') == 'ERROR':
                critical_count += 1
            elif result.get('status') == 'WARNING':
                warning_count += 1
        
        diagnosis['issues_found'] = all_issues
        
        # ç”Ÿæˆå»ºè­°
        recommendations = []
        
        if critical_count > 0:
            recommendations.append("ğŸ”¥ ç™¼ç¾é—œéµå•é¡Œï¼Œéœ€è¦ç«‹å³ä¿®å¾©")
            diagnosis['overall_health'] = 'CRITICAL'
        elif warning_count > 2:
            recommendations.append("âš ï¸ ç™¼ç¾å¤šå€‹è­¦å‘Šï¼Œå»ºè­°æª¢æŸ¥å’Œå„ªåŒ–")
            diagnosis['overall_health'] = 'WARNING'
        elif warning_count > 0:
            recommendations.append("ğŸ’¡ ç™¼ç¾è¼•å¾®å•é¡Œï¼Œå»ºè­°å®šæœŸæª¢æŸ¥")
            diagnosis['overall_health'] = 'MINOR_ISSUES'
        else:
            recommendations.append("âœ… ç³»çµ±ç‹€æ…‹è‰¯å¥½")
            diagnosis['overall_health'] = 'HEALTHY'
        
        # å…·é«”å»ºè­°
        if any('è¨˜æ†¶é«”' in issue for issue in all_issues):
            recommendations.append("è€ƒæ…®å•Ÿç”¨æµå¼è™•ç†æ¨¡å¼")
        
        if any('ç²¾åº¦' in issue for issue in all_issues):
            recommendations.append("æª¢æŸ¥æ™‚é–“åŸºæº–è¨­ç½®å’ŒTLEæ•¸æ“šå“è³ª")
        
        if any('æ€§èƒ½' in issue for issue in all_issues):
            recommendations.append("å„ªåŒ–è¨ˆç®—ç®—æ³•æˆ–å¢åŠ è¨ˆç®—è³‡æº")
        
        if any('ä¾è³´' in issue or 'å¥—ä»¶' in issue for issue in all_issues):
            recommendations.append("å®‰è£ç¼ºå¤±çš„ä¾è³´å¥—ä»¶")
        
        diagnosis['recommendations'] = recommendations
    
    def export_diagnosis_report(self, file_path: str):
        """å°å‡ºè¨ºæ–·å ±å‘Š"""
        if not self.diagnostic_results:
            logger.error("ç„¡è¨ºæ–·çµæœå¯å°å‡º")
            return
        
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(self.diagnostic_results, f, 
                         indent=2, ensure_ascii=False, default=str)
            
            logger.info(f"è¨ºæ–·å ±å‘Šå·²å°å‡ºåˆ°: {file_path}")
        except Exception as e:
            logger.error(f"å°å‡ºè¨ºæ–·å ±å‘Šå¤±æ•—: {e}")
    
    def quick_health_check(self) -> str:
        """å¿«é€Ÿå¥åº·æª¢æŸ¥"""
        try:
            # åŸºæœ¬ç’°å¢ƒæª¢æŸ¥
            if sys.version_info < (3, 8):
                return "CRITICAL: Pythonç‰ˆæœ¬éä½"
            
            # è¨˜æ†¶é«”æª¢æŸ¥
            memory = psutil.virtual_memory()
            if memory.available < 1 * 1024**3:
                return "WARNING: è¨˜æ†¶é«”ä¸è¶³"
            
            # ä¾è³´æª¢æŸ¥
            try:
                import numpy, skyfield, astropy
                return "HEALTHY: åŸºæœ¬ç’°å¢ƒæ­£å¸¸"
            except ImportError as e:
                return f"ERROR: ç¼ºå°‘ä¾è³´ {e}"
                
        except Exception as e:
            return f"ERROR: å¥åº·æª¢æŸ¥å¤±æ•— {e}"
```

### 2. æ™‚é–“åŸºæº–éŒ¯èª¤å°ˆé …è¨ºæ–·

**debugging/time_diagnosis.py å¯¦ç¾ï¼š**
```python
#!/usr/bin/env python3
"""
æ™‚é–“åŸºæº–å°ˆé …è¨ºæ–·
é‡å°æœ€å¸¸è¦‹çš„æ™‚é–“åŸºæº–éŒ¯èª¤æä¾›å°ˆé …è¨ºæ–·
"""

import logging
from typing import Dict, List
from datetime import datetime, timezone, timedelta
import numpy as np

from ..data.parser import TLEData
from ..calculation.sgp4_engine import SGP4Calculator

logger = logging.getLogger(__name__)

class TimeBasisDiagnostic:
    """æ™‚é–“åŸºæº–å°ˆé …è¨ºæ–·"""
    
    def diagnose_time_basis_error(self, 
                                tle_data: TLEData, 
                                calculation_time: datetime) -> Dict:
        """
        è¨ºæ–·æ™‚é–“åŸºæº–éŒ¯èª¤
        
        é€™æ˜¯æœ€å¸¸è¦‹å’Œæœ€è‡´å‘½çš„éŒ¯èª¤ï¼š8000+è¡›æ˜Ÿâ†’0é¡†å¯è¦‹
        
        Args:
            tle_data: TLEæ•¸æ“š
            calculation_time: è¨ˆç®—æ™‚é–“
            
        Returns:
            Dict: è¨ºæ–·çµæœ
        """
        diagnosis = {
            'error_detected': False,
            'error_type': None,
            'severity': 'INFO',
            'time_analysis': {},
            'recommendations': []
        }
        
        try:
            # ç²å–TLE epochæ™‚é–“
            tle_epoch = tle_data.get_epoch_datetime()
            
            # è¨ˆç®—æ™‚é–“å·®
            time_diff = (calculation_time - tle_epoch).total_seconds()
            time_diff_days = time_diff / (24 * 3600)
            time_diff_hours = time_diff / 3600
            
            diagnosis['time_analysis'] = {
                'tle_epoch': tle_epoch.isoformat(),
                'calculation_time': calculation_time.isoformat(),
                'time_difference_seconds': time_diff,
                'time_difference_days': time_diff_days,
                'time_difference_hours': time_diff_hours
            }
            
            # æª¢æŸ¥æ™‚é–“åŸºæº–éŒ¯èª¤
            if abs(time_diff_days) > 30:
                diagnosis['error_detected'] = True
                diagnosis['error_type'] = 'CRITICAL_TIME_GAP'
                diagnosis['severity'] = 'CRITICAL'
                diagnosis['recommendations'].append(
                    f"æ™‚é–“å·®éå¤§({time_diff_days:.1f}å¤©)ï¼"
                    "é€™æœƒå°è‡´è»Œé“é æ¸¬å®Œå…¨ä¸æº–ç¢ºã€‚"
                    "è«‹ä½¿ç”¨TLE epochæ™‚é–“ä½œç‚ºåŸºæº–æ™‚é–“é€²è¡Œè¨ˆç®—ã€‚"
                )
            elif abs(time_diff_days) > 14:
                diagnosis['error_detected'] = True
                diagnosis['error_type'] = 'WARNING_TIME_GAP'
                diagnosis['severity'] = 'WARNING'
                diagnosis['recommendations'].append(
                    f"æ™‚é–“å·®è¼ƒå¤§({time_diff_days:.1f}å¤©)ï¼Œ"
                    "è»Œé“é æ¸¬ç²¾åº¦å¯èƒ½ä¸‹é™ã€‚"
                )
            elif abs(time_diff_days) > 7:
                diagnosis['error_detected'] = True
                diagnosis['error_type'] = 'MINOR_TIME_GAP'
                diagnosis['severity'] = 'INFO'
                diagnosis['recommendations'].append(
                    f"æ™‚é–“å·®{time_diff_days:.1f}å¤©ï¼Œåœ¨å¯æ¥å—ç¯„åœå…§ä½†å»ºè­°æ›´æ–°TLEæ•¸æ“šã€‚"
                )
            
            # æª¢æŸ¥æ˜¯å¦ä½¿ç”¨äº†ç•¶å‰æ™‚é–“è€Œéepochæ™‚é–“
            current_time = datetime.now(timezone.utc)
            diff_to_current = abs((calculation_time - current_time).total_seconds())
            
            if diff_to_current < 3600:  # è¨ˆç®—æ™‚é–“æ¥è¿‘ç•¶å‰æ™‚é–“
                diagnosis['time_analysis']['likely_using_current_time'] = True
                if abs(time_diff_days) > 3:
                    diagnosis['error_detected'] = True
                    diagnosis['error_type'] = 'CURRENT_TIME_USAGE_ERROR'
                    diagnosis['severity'] = 'CRITICAL'
                    diagnosis['recommendations'].append(
                        "âš ï¸ æª¢æ¸¬åˆ°å¯èƒ½ä½¿ç”¨äº†ç•¶å‰æ™‚é–“é€²è¡Œè»Œé“è¨ˆç®—ï¼"
                        "é€™æ˜¯å°è‡´8000+è¡›æ˜Ÿâ†’0é¡†å¯è¦‹çš„ä¸»è¦åŸå› ã€‚"
                        "æ­£ç¢ºåšæ³•ï¼šä½¿ç”¨TLE epochæ™‚é–“ä½œç‚ºè¨ˆç®—åŸºæº–ã€‚"
                    )
            else:
                diagnosis['time_analysis']['likely_using_current_time'] = False
            
            # æª¢æŸ¥epochæ™‚é–“æ˜¯å¦åˆç†
            if tle_epoch.year < 1957 or tle_epoch.year > 2030:
                diagnosis['error_detected'] = True
                diagnosis['error_type'] = 'INVALID_EPOCH_YEAR'
                diagnosis['severity'] = 'ERROR'
                diagnosis['recommendations'].append(
                    f"TLE epochå¹´ä»½ç•°å¸¸: {tle_epoch.year}ï¼Œ"
                    "è«‹æª¢æŸ¥TLEæ•¸æ“šè§£ææ˜¯å¦æ­£ç¢ºã€‚"
                )
            
        except Exception as e:
            diagnosis['error_detected'] = True
            diagnosis['error_type'] = 'TIME_ANALYSIS_FAILED'
            diagnosis['severity'] = 'ERROR'
            diagnosis['recommendations'].append(f"æ™‚é–“åˆ†æå¤±æ•—: {e}")
        
        return diagnosis
    
    def demonstrate_time_basis_impact(self, tle_data: TLEData) -> Dict:
        """
        æ¼”ç¤ºæ™‚é–“åŸºæº–éŒ¯èª¤çš„å½±éŸ¿
        
        Args:
            tle_data: TLEæ•¸æ“š
            
        Returns:
            Dict: å½±éŸ¿æ¼”ç¤ºçµæœ
        """
        calculator = SGP4Calculator()
        tle_epoch = tle_data.get_epoch_datetime()
        current_time = datetime.now(timezone.utc)
        
        results = {}
        
        try:
            # 1. æ­£ç¢ºæ–¹æ³•ï¼šä½¿ç”¨TLE epochæ™‚é–“
            correct_result = calculator.calculate_satellite_position(
                tle_data, tle_epoch
            )
            
            # 2. éŒ¯èª¤æ–¹æ³•ï¼šä½¿ç”¨ç•¶å‰æ™‚é–“
            wrong_result = calculator.calculate_satellite_position(
                tle_data, current_time
            )
            
            # è¨ˆç®—ä½ç½®å·®ç•°
            correct_pos = np.array(correct_result['position_eci_km'])
            wrong_pos = np.array(wrong_result['position_eci_km'])
            position_difference = np.linalg.norm(wrong_pos - correct_pos)
            
            # è¨ˆç®—é«˜åº¦å·®ç•°
            earth_radius = 6371.0
            correct_alt = np.linalg.norm(correct_pos) - earth_radius
            wrong_alt = np.linalg.norm(wrong_pos) - earth_radius
            
            results = {
                'time_difference_days': (current_time - tle_epoch).total_seconds() / (24 * 3600),
                'correct_method': {
                    'calculation_time': tle_epoch.isoformat(),
                    'position_eci_km': correct_pos.tolist(),
                    'altitude_km': correct_alt,
                    'method': 'TLE epochæ™‚é–“ï¼ˆæ­£ç¢ºï¼‰'
                },
                'wrong_method': {
                    'calculation_time': current_time.isoformat(),
                    'position_eci_km': wrong_pos.tolist(),
                    'altitude_km': wrong_alt,
                    'method': 'ç•¶å‰ç³»çµ±æ™‚é–“ï¼ˆéŒ¯èª¤ï¼‰'
                },
                'impact_analysis': {
                    'position_difference_km': position_difference,
                    'altitude_difference_km': abs(wrong_alt - correct_alt),
                    'impact_severity': self._assess_impact_severity(position_difference)
                }
            }
            
        except Exception as e:
            results['error'] = f"å½±éŸ¿æ¼”ç¤ºå¤±æ•—: {e}"
        
        return results
    
    def _assess_impact_severity(self, position_diff_km: float) -> str:
        """è©•ä¼°æ™‚é–“åŸºæº–éŒ¯èª¤çš„å½±éŸ¿åš´é‡ç¨‹åº¦"""
        if position_diff_km > 10000:
            return "CATASTROPHIC - è»Œé“é æ¸¬å®Œå…¨éŒ¯èª¤"
        elif position_diff_km > 1000:
            return "SEVERE - è»Œé“é æ¸¬åš´é‡åå·®"
        elif position_diff_km > 100:
            return "MAJOR - è»Œé“é æ¸¬é‡å¤§åå·®"
        elif position_diff_km > 10:
            return "MODERATE - è»Œé“é æ¸¬ä¸­åº¦åå·®"
        elif position_diff_km > 1:
            return "MINOR - è»Œé“é æ¸¬è¼•å¾®åå·®"
        else:
            return "NEGLIGIBLE - å½±éŸ¿å¯å¿½ç•¥"
```

## è‡ªå‹•åŒ–æ•…éšœä¿®å¾©æ©Ÿåˆ¶

### è‡ªå‹•ä¿®å¾©å™¨å¯¦ç¾

**debugging/auto_repair.py å¯¦ç¾ï¼š**
```python
#!/usr/bin/env python3
"""
è‡ªå‹•æ•…éšœä¿®å¾©å™¨
å¯¦ç¾å¸¸è¦‹å•é¡Œçš„è‡ªå‹•æª¢æ¸¬å’Œä¿®å¾©
"""

import logging
import os
import shutil
from typing import Dict, List, Optional
from datetime import datetime

logger = logging.getLogger(__name__)

class AutoRepairSystem:
    """è‡ªå‹•æ•…éšœä¿®å¾©ç³»çµ±"""
    
    def __init__(self):
        """åˆå§‹åŒ–è‡ªå‹•ä¿®å¾©ç³»çµ±"""
        self.repair_log = []
        self.supported_repairs = [
            'clear_cache',
            'reset_configuration',
            'cleanup_memory',
            'update_time_reference',
            'repair_tle_data',
            'optimize_performance'
        ]
    
    def attempt_auto_repair(self, diagnosis: Dict) -> Dict:
        """
        å˜—è©¦è‡ªå‹•ä¿®å¾©æª¢æ¸¬åˆ°çš„å•é¡Œ
        
        Args:
            diagnosis: è¨ºæ–·çµæœ
            
        Returns:
            Dict: ä¿®å¾©çµæœ
        """
        repair_result = {
            'timestamp': datetime.now().isoformat(),
            'attempted_repairs': [],
            'successful_repairs': [],
            'failed_repairs': [],
            'recommendations_for_manual_fix': []
        }
        
        issues = diagnosis.get('issues_found', [])
        
        for issue in issues:
            repair_action = self._identify_repair_action(issue)
            
            if repair_action:
                repair_result['attempted_repairs'].append({
                    'issue': issue,
                    'action': repair_action
                })
                
                success = self._execute_repair(repair_action, issue)
                
                if success:
                    repair_result['successful_repairs'].append(repair_action)
                    logger.info(f"è‡ªå‹•ä¿®å¾©æˆåŠŸ: {repair_action}")
                else:
                    repair_result['failed_repairs'].append(repair_action)
                    repair_result['recommendations_for_manual_fix'].append(
                        self._get_manual_fix_recommendation(issue)
                    )
                    logger.warning(f"è‡ªå‹•ä¿®å¾©å¤±æ•—: {repair_action}")
            else:
                repair_result['recommendations_for_manual_fix'].append(
                    self._get_manual_fix_recommendation(issue)
                )
        
        return repair_result
    
    def _identify_repair_action(self, issue: str) -> Optional[str]:
        """è­˜åˆ¥å•é¡Œå°æ‡‰çš„ä¿®å¾©å‹•ä½œ"""
        issue_lower = issue.lower()
        
        if 'å¿«å–' in issue_lower or 'cache' in issue_lower:
            return 'clear_cache'
        elif 'è¨˜æ†¶é«”' in issue_lower or 'memory' in issue_lower:
            return 'cleanup_memory'
        elif 'æ™‚é–“' in issue_lower or 'time' in issue_lower or 'epoch' in issue_lower:
            return 'update_time_reference'
        elif 'tle' in issue_lower and ('æ ¼å¼' in issue_lower or 'è§£æ' in issue_lower):
            return 'repair_tle_data'
        elif 'æ€§èƒ½' in issue_lower or 'performance' in issue_lower:
            return 'optimize_performance'
        elif 'é…ç½®' in issue_lower or 'config' in issue_lower:
            return 'reset_configuration'
        else:
            return None
    
    def _execute_repair(self, repair_action: str, issue: str) -> bool:
        """åŸ·è¡Œä¿®å¾©å‹•ä½œ"""
        try:
            if repair_action == 'clear_cache':
                return self._clear_all_caches()
            elif repair_action == 'cleanup_memory':
                return self._cleanup_memory()
            elif repair_action == 'update_time_reference':
                return self._update_time_reference()
            elif repair_action == 'repair_tle_data':
                return self._repair_tle_data()
            elif repair_action == 'optimize_performance':
                return self._optimize_performance()
            elif repair_action == 'reset_configuration':
                return self._reset_configuration()
            else:
                return False
        except Exception as e:
            logger.error(f"åŸ·è¡Œä¿®å¾©å‹•ä½œ {repair_action} æ™‚ç™¼ç”ŸéŒ¯èª¤: {e}")
            return False
    
    def _clear_all_caches(self) -> bool:
        """æ¸…é™¤æ‰€æœ‰å¿«å–"""
        try:
            # æ¸…é™¤è¨ˆç®—å™¨å¿«å–
            from ..calculation.sgp4_engine import SGP4Calculator
            calculator = SGP4Calculator()
            calculator.clear_cache()
            
            # æ¸…é™¤æ•¸æ“šè¼‰å…¥å™¨å¿«å–
            from ..data.loader import TLEDataLoader
            loader = TLEDataLoader()
            loader.clear_cache()
            
            logger.info("æ‰€æœ‰å¿«å–å·²æ¸…é™¤")
            return True
        except Exception as e:
            logger.error(f"æ¸…é™¤å¿«å–å¤±æ•—: {e}")
            return False
    
    def _cleanup_memory(self) -> bool:
        """æ¸…ç†è¨˜æ†¶é«”"""
        try:
            import gc
            
            # å¼·åˆ¶åƒåœ¾å›æ”¶
            collected = gc.collect()
            
            # æ¸…é™¤å¿«å–
            self._clear_all_caches()
            
            logger.info(f"è¨˜æ†¶é«”æ¸…ç†å®Œæˆï¼Œå›æ”¶äº† {collected} å€‹å°è±¡")
            return True
        except Exception as e:
            logger.error(f"è¨˜æ†¶é«”æ¸…ç†å¤±æ•—: {e}")
            return False
    
    def _update_time_reference(self) -> bool:
        """æ›´æ–°æ™‚é–“åŸºæº–è¨­ç½®"""
        try:
            # é€™å€‹ä¿®å¾©ä¸»è¦æ˜¯æé†’å’Œé…ç½®æª¢æŸ¥
            logger.info("æ™‚é–“åŸºæº–æª¢æŸ¥ï¼šç¢ºä¿ä½¿ç”¨TLE epochæ™‚é–“é€²è¡Œè¨ˆç®—")
            
            # æª¢æŸ¥æ˜¯å¦æœ‰æ™‚é–“åŸºæº–é…ç½®æª”æ¡ˆ
            config_file = 'time_config.json'
            if os.path.exists(config_file):
                import json
                with open(config_file, 'r') as f:
                    config = json.load(f)
                
                # æ›´æ–°é…ç½®ç¢ºä¿ä½¿ç”¨æ­£ç¢ºçš„æ™‚é–“åŸºæº–
                config['use_tle_epoch_time'] = True
                config['warn_large_time_gap'] = True
                config['max_time_gap_days'] = 30
                
                with open(config_file, 'w') as f:
                    json.dump(config, f, indent=2)
                
                logger.info("æ™‚é–“åŸºæº–é…ç½®å·²æ›´æ–°")
            else:
                # å‰µå»ºé è¨­æ™‚é–“åŸºæº–é…ç½®
                default_config = {
                    'use_tle_epoch_time': True,
                    'warn_large_time_gap': True,
                    'max_time_gap_days': 30,
                    'created_by_auto_repair': True,
                    'creation_time': datetime.now().isoformat()
                }
                
                with open(config_file, 'w') as f:
                    json.dump(default_config, f, indent=2)
                
                logger.info("å‰µå»ºäº†é è¨­æ™‚é–“åŸºæº–é…ç½®")
            
            return True
        except Exception as e:
            logger.error(f"æ›´æ–°æ™‚é–“åŸºæº–å¤±æ•—: {e}")
            return False
    
    def _repair_tle_data(self) -> bool:
        """ä¿®å¾©TLEæ•¸æ“šå•é¡Œ"""
        try:
            # é€™è£¡å¯¦ç¾åŸºæœ¬çš„TLEæ•¸æ“šä¿®å¾©é‚è¼¯
            # å¯¦éš›æ‡‰ç”¨ä¸­å¯èƒ½éœ€è¦æ›´è¤‡é›œçš„ä¿®å¾©ç­–ç•¥
            
            logger.info("TLEæ•¸æ“šä¿®å¾©ï¼šå»ºè­°é‡æ–°ä¸‹è¼‰æœ€æ–°çš„TLEæ•¸æ“š")
            
            # å‰µå»ºæ•¸æ“šä¿®å¾©å»ºè­°æª”æ¡ˆ
            repair_suggestions = {
                'tle_data_repair_suggestions': [
                    'æª¢æŸ¥TLEæ•¸æ“šä¾†æºæ˜¯å¦æ­£ç¢º',
                    'é©—è­‰TLEæª”æ¡ˆç·¨ç¢¼æ ¼å¼ï¼ˆUTF-8ï¼‰',
                    'ç¢ºèªTLEè¡Œæ ¼å¼ç¬¦åˆæ¨™æº–ï¼ˆæ¯çµ„3è¡Œï¼‰',
                    'æª¢æŸ¥TLEæª¢æŸ¥ç¢¼æ˜¯å¦æ­£ç¢º',
                    'è€ƒæ…®å¾Space-Track.orgé‡æ–°ä¸‹è¼‰æœ€æ–°æ•¸æ“š'
                ],
                'generated_time': datetime.now().isoformat()
            }
            
            import json
            with open('tle_repair_suggestions.json', 'w') as f:
                json.dump(repair_suggestions, f, indent=2, ensure_ascii=False)
            
            return True
        except Exception as e:
            logger.error(f"TLEæ•¸æ“šä¿®å¾©å»ºè­°ç”Ÿæˆå¤±æ•—: {e}")
            return False
    
    def _optimize_performance(self) -> bool:
        """å„ªåŒ–æ€§èƒ½è¨­ç½®"""
        try:
            # å‰µå»ºæ€§èƒ½å„ªåŒ–é…ç½®
            perf_config = {
                'batch_size': 100,
                'max_threads': 4,
                'enable_caching': True,
                'memory_limit_mb': 4096,
                'enable_stream_processing': True,
                'optimization_applied': True,
                'applied_time': datetime.now().isoformat()
            }
            
            import json
            with open('performance_config.json', 'w') as f:
                json.dump(perf_config, f, indent=2)
            
            logger.info("æ€§èƒ½å„ªåŒ–é…ç½®å·²æ‡‰ç”¨")
            return True
        except Exception as e:
            logger.error(f"æ€§èƒ½å„ªåŒ–å¤±æ•—: {e}")
            return False
    
    def _reset_configuration(self) -> bool:
        """é‡ç½®é…ç½®åˆ°é è¨­ç‹€æ…‹"""
        try:
            config_files = [
                'config.json',
                'time_config.json', 
                'performance_config.json'
            ]
            
            # å‚™ä»½ç¾æœ‰é…ç½®
            backup_dir = f'config_backup_{datetime.now().strftime("%Y%m%d_%H%M%S")}'
            os.makedirs(backup_dir, exist_ok=True)
            
            for config_file in config_files:
                if os.path.exists(config_file):
                    shutil.copy2(config_file, os.path.join(backup_dir, config_file))
                    os.remove(config_file)
            
            logger.info(f"é…ç½®å·²é‡ç½®ï¼Œå‚™ä»½ä¿å­˜åœ¨ {backup_dir}")
            return True
        except Exception as e:
            logger.error(f"é‡ç½®é…ç½®å¤±æ•—: {e}")
            return False
    
    def _get_manual_fix_recommendation(self, issue: str) -> str:
        """ç²å–æ‰‹å‹•ä¿®å¾©å»ºè­°"""
        issue_lower = issue.lower()
        
        if 'pythonç‰ˆæœ¬' in issue_lower or 'python' in issue_lower and 'ç‰ˆæœ¬' in issue_lower:
            return "è«‹å‡ç´šPythonåˆ°3.8æˆ–æ›´é«˜ç‰ˆæœ¬"
        elif 'å¥—ä»¶' in issue_lower or 'package' in issue_lower:
            return "è«‹å®‰è£ç¼ºå¤±çš„Pythonå¥—ä»¶ï¼špip install -r requirements.txt"
        elif 'æ¬Šé™' in issue_lower or 'permission' in issue_lower:
            return "è«‹æª¢æŸ¥æª”æ¡ˆå’Œç›®éŒ„æ¬Šé™è¨­ç½®"
        elif 'ç£ç¢Ÿç©ºé–“' in issue_lower or 'disk' in issue_lower:
            return "è«‹æ¸…ç†ç£ç¢Ÿç©ºé–“æˆ–ç§»å‹•åˆ°æ›´å¤§çš„å„²å­˜è¨­å‚™"
        elif 'tle' in issue_lower and 'æ™‚æ•ˆ' in issue_lower:
            return "è«‹å¾Space-Track.orgä¸‹è¼‰æœ€æ–°çš„TLEæ•¸æ“š"
        else:
            return f"æ‰‹å‹•æª¢æŸ¥å’Œä¿®å¾©ï¼š{issue}"
```

## éšæ®µç¸½çµ

### éšæ®µ8å­¸ç¿’æˆæœç¢ºèªï¼š

**æŒæ¡çš„æ ¸å¿ƒæŠ€è¡“ï¼š**
- ç³»çµ±æ€§æ•…éšœè¨ºæ–·å’Œåˆ†é¡æ–¹æ³•
- è‡ªå‹•åŒ–å•é¡Œæª¢æ¸¬å’Œä¿®å¾©æ©Ÿåˆ¶
- æ™‚é–“åŸºæº–éŒ¯èª¤çš„å°ˆé …è¨ºæ–·æŠ€è¡“
- ç”Ÿç”¢ç´šç³»çµ±çš„ç›£æ§å’Œç¶­é‹æŠ€èƒ½
- è¤‡é›œç³»çµ±çš„æ•…éšœéš”é›¢å’Œæ¢å¾©ç­–ç•¥

**å®Œæˆçš„é™¤éŒ¯å·¥ä½œï¼š**
- DiagnosticToolç¶œåˆè¨ºæ–·ç³»çµ±
- TimeBasisDiagnosticæ™‚é–“å°ˆé …è¨ºæ–·
- AutoRepairSystemè‡ªå‹•ä¿®å¾©ç³»çµ±
- å®Œæ•´çš„æ•…éšœåˆ†é¡å’Œè™•ç†æµç¨‹
- è©³ç´°çš„ä¿®å¾©å»ºè­°å’Œæ“ä½œæŒ‡å—

**å¯¦éš›æ‡‰ç”¨èƒ½åŠ›ï¼š**
- èƒ½å¤ å¿«é€Ÿå®šä½å’Œè§£æ±ºè¡›æ˜Ÿè»Œé“è¨ˆç®—ç³»çµ±æ•…éšœ
- å…·å‚™è¤‡é›œç³»çµ±çš„é‹ç¶­å’Œæ•…éšœæ’é™¤ç¶“é©—
- æŒæ¡è‡ªå‹•åŒ–ç›£æ§å’Œä¿®å¾©æŠ€è¡“
- ç†è§£èˆªå¤ªç³»çµ±çš„é«˜å¯é æ€§å’Œå®¹éŒ¯è¨­è¨ˆ

**å®Œæ•´èª²ç¨‹ç¸½çµï¼š**
ç¶“é8å€‹éšæ®µçš„ç³»çµ±å­¸ç¿’ï¼Œæ‚¨ç¾åœ¨å…·å‚™äº†ï¼š
1. **LEOè¡›æ˜Ÿé€šè¨Šç³»çµ±åŸºç¤çŸ¥è­˜** (éšæ®µ1)
2. **TLEæ•¸æ“šæ ¼å¼çš„å®Œå…¨æŒæ¡** (éšæ®µ2)
3. **SGP4ç®—æ³•çš„æ·±åº¦ç†è§£** (éšæ®µ3)
4. **åº§æ¨™ç³»çµ±è½‰æ›çš„ç²¾ç¢ºå¯¦ç¾** (éšæ®µ4)
5. **Stage1TLEProcessorçš„æ¶æ§‹è¨­è¨ˆ** (éšæ®µ5)
6. **å®Œæ•´ç³»çµ±çš„ç¨‹å¼å¯¦ä½œ** (éšæ®µ6)
7. **æ•¸æ“šé©—è­‰å’Œå“è³ªæ§åˆ¶** (éšæ®µ7)
8. **é™¤éŒ¯å’Œæ•…éšœæ’é™¤** (éšæ®µ8)

**è·æ¥­æˆå°±è§£é–ï¼š**
- âœ… è¡›æ˜Ÿç³»çµ±å·¥ç¨‹å¸«æ ¸å¿ƒæŠ€èƒ½
- âœ… 8000+é¡†è¡›æ˜Ÿæ‰¹é‡è™•ç†èƒ½åŠ›
- âœ… ç”Ÿç”¢ç´šè»Ÿé«”é–‹ç™¼ç¶“é©—
- âœ… èˆªå¤ªå·¥ç¨‹å¯¦éš›æ‡‰ç”¨æŠ€è¡“
- âœ… å­¸è¡“ç ”ç©¶å’Œè«–æ–‡ç™¼è¡¨åŸºç¤

## æ•…éšœæ’é™¤æœ€ä½³å¯¦è¸

### 1. é‡‘å¾‹ï¼šæ™‚é–“åŸºæº–çµ•ä¸å‡ºéŒ¯
- **æ°¸é ä½¿ç”¨TLE epochæ™‚é–“ä½œç‚ºè¨ˆç®—åŸºæº–**
- **çµ•ä¸ä½¿ç”¨ç•¶å‰ç³»çµ±æ™‚é–“é€²è¡Œè»Œé“è¨ˆç®—**
- **æ™‚é–“å·®>3å¤©ç«‹å³ç™¼å‡ºè­¦å‘Š**

### 2. è¨ºæ–·å„ªå…ˆé †åº
1. **æ™‚é–“åŸºæº–æª¢æŸ¥** - æœ€å¸¸è¦‹è‡´å‘½éŒ¯èª¤
2. **TLEæ•¸æ“šæ ¼å¼é©—è­‰** - åŸºç¤æ•¸æ“šå®Œæ•´æ€§
3. **ç‰©ç†åˆç†æ€§æª¢æŸ¥** - çµæœæ­£ç¢ºæ€§é©—è­‰
4. **ç³»çµ±è³‡æºç›£æ§** - æ€§èƒ½å’Œç©©å®šæ€§

### 3. è‡ªå‹•åŒ–ä¿®å¾©åŸå‰‡
- **èƒ½è‡ªå‹•ä¿®å¾©çš„å•é¡Œç«‹å³ä¿®å¾©**
- **ä¸èƒ½è‡ªå‹•ä¿®å¾©çš„æä¾›æ˜ç¢ºæŒ‡å°**
- **æ‰€æœ‰ä¿®å¾©å‹•ä½œéƒ½æœ‰å®Œæ•´è¨˜éŒ„**
- **é—œéµå•é¡Œéœ€è¦äººå·¥ç¢ºèª**

### 4. é é˜²æ€§ç¶­è­·
- **å®šæœŸæ›´æ–°TLEæ•¸æ“šï¼ˆå»ºè­°æ¯é€±ï¼‰**
- **ç›£æ§ç³»çµ±æ€§èƒ½æŒ‡æ¨™**
- **å®šæœŸé€²è¡Œç²¾åº¦æ¯”è¼ƒæ¸¬è©¦**
- **ç¶­è­·è©³ç´°çš„æ“ä½œæ—¥èªŒ**

**æ­å–œï¼æ‚¨å·²å®ŒæˆStage1TLEProcessorçš„å®Œæ•´é–‹ç™¼èª²ç¨‹ï¼** ğŸ‰