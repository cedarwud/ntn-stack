# 🎯 v6.0 六階段統一重構指導文檔

**版本**: v6.0.0
**創建日期**: 2025-09-17
**專案狀態**: 🚨 重構指導文檔 - 統一時間基準與精度提升
**適用範圍**: 所有六階段處理器 + Shared Core架構

## 📋 重構背景與目標

### 🚨 關鍵問題識別

**根本問題**: 當前六階段系統存在時間基準不一致和計算精度差異，導致：
- **Stage 2零可見性問題**: 2,272顆衛星處理但零可見結果
- **時間基準混亂**: Stage 1和Stage 2使用不同時間基準
- **精度不一致**: 單檔案計算器(3,240顆) vs 多階段系統(2,272顆)的準確性差異
- **學術標準違規**: 違反Grade A學術數據標準要求

### 🎯 v6.0 統一重構目標

**核心目標**: 建立可靠的時間基準繼承機制和高精度計算標準，實現：
1. **時間基準統一**: 所有六階段使用相同的TLE epoch時間基準
2. **計算庫標準化**: 統一使用Skyfield庫實現學術級精度
3. **數據傳遞優化**: 高精度無損失數據傳遞機制
4. **學術合規保證**: 100%符合Grade A學術標準要求

## 🚨 v6.0 重構優先級清單

### 🔴 Priority 1: 時間基準統一 (立即執行)

#### Stage 1 修復要求
**文件**: `src/stages/stage1_orbital_calculation/tle_orbital_calculation_processor.py`

**必須修復的問題**:
```python
# ❌ 當前問題：_get_tle_epoch_time方法可能回退到當前時間
def _get_tle_epoch_time(self, orbital_results: Dict[str, Any]) -> str:
    # 當前代碼可能使用 datetime.now() 作為回退

# ✅ v6.0 修復：強制使用TLE epoch時間，禁止任何回退
def _get_tle_epoch_time(self, orbital_results: Dict[str, Any]) -> str:
    """
    從軌道結果獲取TLE epoch時間 - v6.0重構：強制使用真實TLE epoch時間
    """
    # 從SGP4引擎獲取TLE epoch時間
    tle_epoch = orbital_results.get("tle_epoch_time")

    if tle_epoch:
        self.logger.info(f"🎯 v6.0重構：使用SGP4引擎的TLE epoch時間: {tle_epoch}")
        return tle_epoch

    # v6.0重構：絕對禁止使用當前時間作為回退！
    raise ValueError("v6.0重構：無法獲取真實TLE epoch時間，拒絕使用當前系統時間作為回退")
```

**metadata輸出要求**:
```python
# ✅ v6.0 要求：Stage 1必須輸出正確的時間基準信息
metadata = {
    "calculation_base_time": tle_epoch_time,  # 來自TLE數據，非當前時間
    "tle_epoch_time": tle_epoch_time,         # 原始TLE epoch時間
    "time_base_source": "tle_epoch_derived",  # 標識來源
    "tle_epoch_compliance": True,             # 合規性標記
    "stage1_time_inheritance": {              # v6.0 新增
        "exported_time_base": tle_epoch_time,
        "inheritance_ready": True,
        "calculation_reference": "tle_epoch_based"
    }
}
```

#### Stage 2 修復要求
**文件**: `src/stages/stage2_visibility_filter/satellite_visibility_filter_processor.py`

**必須修復的問題**:
```python
# ✅ v6.0 修復：正確繼承Stage 1時間基準
def load_stage1_output(self) -> Dict[str, Any]:
    """載入Stage 1軌道計算輸出並繼承時間基準"""
    stage1_data = self.orbital_data_loader.load_stage1_output()

    # 🚨 v6.0 重構：檢查並使用繼承的時間基準
    inherited_time_base = stage1_data.get("inherited_time_base")
    if inherited_time_base:
        self.logger.info(f"🎯 v6.0 重構：使用繼承的Stage 1時間基準: {inherited_time_base}")
        self.calculation_base_time = inherited_time_base
    else:
        self.logger.error("❌ Stage 1數據中未找到inherited_time_base")
        raise ValueError("v6.0重構：Stage 2無法繼承時間基準，Stage 1輸出不符合要求")

    return stage1_data
```

**輔助文件修復**:
**文件**: `src/stages/stage2_visibility_filter/orbital_data_loader.py`

```python
# ✅ v6.0 修復：添加時間基準提取方法
def _extract_stage1_time_base(self, stage1_data: Dict[str, Any]) -> str:
    """從Stage 1 metadata提取計算基準時間 - v6.0 重構：確保Stage 2正確繼承Stage 1的時間基準"""
    try:
        metadata = stage1_data.get("metadata", {})

        # 優先使用TLE epoch時間
        tle_epoch_time = metadata.get("tle_epoch_time")
        calculation_base_time = metadata.get("calculation_base_time")

        if tle_epoch_time:
            self.logger.info(f"🎯 使用Stage 1 TLE epoch時間: {tle_epoch_time}")
            return tle_epoch_time
        elif calculation_base_time:
            self.logger.info(f"🎯 使用Stage 1計算基準時間: {calculation_base_time}")
            return calculation_base_time
        else:
            # 如果都找不到，這是一個嚴重問題
            raise ValueError("Stage 1 metadata缺失時間基準信息，無法執行時間基準繼承")
    except Exception as e:
        self.logger.error(f"❌ 提取Stage 1時間基準失敗: {e}")
        raise
```

### 🟡 Priority 2: Skyfield庫標準化 (次要執行)

#### Stage 1 計算引擎替換
**替換目標**: `src/shared/engines/sgp4_orbital_engine.py`

```python
# ✅ v6.0 標準：使用Skyfield進行SGP4計算
from skyfield.api import load, EarthSatellite
from skyfield.timelib import Time

class SkyfieldSGP4Engine:
    def __init__(self):
        self.ts = load.timescale()

    def compute_orbital_positions(self, tle_data: Dict, calculation_base_time: str) -> List[Dict]:
        """使用Skyfield計算軌道位置"""
        # 強制使用TLE epoch時間作為計算基準
        calculation_time = self.ts.ut1_jd(self._convert_to_jd(calculation_base_time))

        # 創建衛星對象
        satellite = EarthSatellite(
            tle_data['line1'],
            tle_data['line2'],
            tle_data['name'],
            ts=self.ts
        )

        # 計算軌道位置
        positions = []
        for offset_minutes in range(0, orbital_period_minutes, 0.5):  # 30秒間隔
            time_point = calculation_time + (offset_minutes / (24 * 60))  # 轉換為天
            geocentric = satellite.at(time_point)

            positions.append({
                "timestamp": time_point.ut1_iso(),
                "position_eci": {
                    "x": geocentric.position.km[0],
                    "y": geocentric.position.km[1],
                    "z": geocentric.position.km[2]
                },
                "velocity_eci": {
                    "x": geocentric.velocity.km_per_s[0],
                    "y": geocentric.velocity.km_per_s[1],
                    "z": geocentric.velocity.km_per_s[2]
                }
            })

        return positions
```

#### Stage 2 座標轉換替換
**增強目標**: Stage 2 的座標轉換邏輯

```python
# ✅ v6.0 標準：使用Skyfield進行座標轉換
from skyfield.api import load, wgs84
from skyfield.timelib import Time

def calculate_topocentric_skyfield(self, satellite_pos: Dict, observer_loc: Dict, time_base: str) -> Dict:
    """使用Skyfield進行高精度座標轉換"""
    ts = load.timescale()

    # 使用繼承的時間基準
    calculation_time = ts.ut1_jd(self._convert_to_jd(time_base))

    # 創建衛星位置
    satellite_skyfield = EarthSatellite(tle_line1, tle_line2, name, ts)
    geocentric = satellite_skyfield.at(calculation_time)

    # 創建觀測者位置
    observer_location = wgs84.latlon(
        observer_loc['latitude'],
        observer_loc['longitude'],
        observer_loc['altitude_m']
    )

    # 計算地平座標
    topocentric = geocentric - observer_location.at(calculation_time)
    alt, az, distance = topocentric.altaz()

    return {
        "elevation_deg": alt.degrees,
        "azimuth_deg": az.degrees,
        "range_km": distance.km,
        "is_visible": alt.degrees >= self.get_elevation_threshold()
    }
```

### 🟢 Priority 3: 驗證框架強化 (配套執行)

#### v6.0 特定驗證項目添加

**Stage 1 新增驗證**:
```python
def _check_time_base_inheritance_ready(self, results: Dict[str, Any]) -> bool:
    """時間基準繼承準備檢查 - v6.0 新增"""
    metadata = results.get("metadata", {})

    # 檢查必要的時間基準信息
    required_fields = [
        "calculation_base_time",
        "tle_epoch_time",
        "time_base_source",
        "stage1_time_inheritance"
    ]

    for field in required_fields:
        if field not in metadata:
            self.logger.error(f"❌ 缺少時間基準繼承必要字段: {field}")
            return False

    # 檢查時間基準來源
    if metadata["time_base_source"] != "tle_epoch_derived":
        self.logger.error(f"❌ 時間基準來源錯誤: {metadata['time_base_source']}")
        return False

    # 檢查繼承準備狀態
    inheritance_info = metadata.get("stage1_time_inheritance", {})
    if not inheritance_info.get("inheritance_ready", False):
        self.logger.error("❌ 時間基準繼承未準備就緒")
        return False

    self.logger.info("✅ 時間基準繼承準備檢查通過")
    return True

def _check_skyfield_integration(self, results: Dict[str, Any]) -> bool:
    """Skyfield庫整合檢查 - v6.0 新增"""
    # 檢查計算引擎類型
    if not hasattr(self.orbital_engine, 'ts'):  # Skyfield timescale object
        self.logger.error("❌ 未使用Skyfield庫進行軌道計算")
        return False

    # 檢查計算精度
    satellites = results.get("satellites", [])
    if satellites:
        sample_sat = satellites[0]
        positions = sample_sat.get("orbital_positions", [])
        if positions:
            sample_pos = positions[0]
            position_eci = sample_pos.get("position_eci", {})

            # 檢查精度 (Skyfield應該提供更高精度)
            x_precision = len(str(position_eci.get("x", 0)).split('.')[-1])
            if x_precision < 3:  # 至少3位小數精度
                self.logger.warning(f"⚠️ 位置精度可能不足: {x_precision}位小數")
                return False

    self.logger.info("✅ Skyfield庫整合檢查通過")
    return True
```

**Stage 2 新增驗證**:
```python
def _check_time_base_inheritance(self, input_data: Dict[str, Any]) -> bool:
    """時間基準繼承驗證 - v6.0 新增"""
    inherited_time_base = input_data.get("inherited_time_base")

    if not inherited_time_base:
        self.logger.error("❌ 未找到Stage 1繼承的時間基準")
        return False

    # 檢查當前processor是否使用了繼承的時間基準
    if not hasattr(self, 'calculation_base_time'):
        self.logger.error("❌ Stage 2未設置計算基準時間")
        return False

    if self.calculation_base_time != inherited_time_base:
        self.logger.error(f"❌ 時間基準不一致: {self.calculation_base_time} vs {inherited_time_base}")
        return False

    self.logger.info(f"✅ 時間基準繼承驗證通過: {inherited_time_base}")
    return True

def _check_visibility_calculation_accuracy(self, results: Dict[str, Any]) -> bool:
    """可見性計算準確性檢查 - v6.0 新增"""
    metadata = results.get("metadata", {})

    # 檢查識別的衛星數量是否達到單檔案計算器的水平
    total_satellites = metadata.get("total_filtered_satellites", 0)
    expected_minimum = 3000  # 基於單檔案計算器的3,240顆結果

    if total_satellites < expected_minimum:
        self.logger.warning(f"⚠️ 可見性識別數量可能不足: {total_satellites} < {expected_minimum}")
        # 這是警告而非錯誤，因為可能是合理的地理限制

    # 檢查可見性比例
    input_satellites = metadata.get("total_input_satellites", 1)
    visibility_rate = total_satellites / input_satellites

    if visibility_rate < 0.30:  # 至少30%可見性
        self.logger.error(f"❌ 可見性比例過低: {visibility_rate:.2%}")
        return False

    self.logger.info(f"✅ 可見性計算準確性檢查通過: {total_satellites}顆 ({visibility_rate:.2%})")
    return True
```

## 🔧 實施步驟詳細指南

### Step 1: Stage 1 時間基準修復

1. **修改 `tle_orbital_calculation_processor.py`**:
   - 修復 `_get_tle_epoch_time` 方法，禁止當前時間回退
   - 添加 `stage1_time_inheritance` metadata 輸出
   - 添加 v6.0 特定驗證項目

2. **測試驗證**:
   ```bash
   # 執行Stage 1並檢查metadata輸出
   docker exec satellite-dev python -c "
   import sys; sys.path.append('/satellite-processing/src')
   from stages.stage1_orbital_calculation.tle_orbital_calculation_processor import Stage1TLEProcessor
   stage1 = Stage1TLEProcessor()
   results = stage1.execute()
   print('calculation_base_time:', results['metadata']['calculation_base_time'])
   print('time_base_source:', results['metadata']['time_base_source'])
   print('inheritance_ready:', results['metadata']['stage1_time_inheritance']['inheritance_ready'])
   "
   ```

3. **預期結果**:
   - `calculation_base_time` 應為TLE epoch時間（如：2025-09-02T12:34:56Z）
   - `time_base_source` 應為 "tle_epoch_derived"
   - `inheritance_ready` 應為 True

### Step 2: Stage 2 時間基準繼承

1. **修改 `satellite_visibility_filter_processor.py`**:
   - 添加時間基準繼承邏輯
   - 添加 v6.0 特定驗證項目
   - 確保所有可見性計算使用繼承的時間基準

2. **修改 `orbital_data_loader.py`**:
   - 添加 `_extract_stage1_time_base` 方法
   - 在 `load_stage1_output` 中設置 `inherited_time_base`

3. **測試驗證**:
   ```bash
   # 執行Stage 1+2並檢查時間基準繼承
   docker exec satellite-dev python -c "
   import sys; sys.path.append('/satellite-processing/src')
   from stages.stage1_orbital_calculation.tle_orbital_calculation_processor import Stage1TLEProcessor
   from stages.stage2_visibility_filter.satellite_visibility_filter_processor import SatelliteVisibilityFilterProcessor

   # 執行Stage 1
   stage1 = Stage1TLEProcessor()
   stage1_results = stage1.execute()

   # 執行Stage 2
   stage2 = SatelliteVisibilityFilterProcessor()
   stage2_results = stage2.execute()

   print('Stage 1 time base:', stage1_results['metadata']['calculation_base_time'])
   print('Stage 2 time base:', stage2.calculation_base_time)
   print('Time base match:', stage1_results['metadata']['calculation_base_time'] == stage2.calculation_base_time)
   "
   ```

4. **預期結果**:
   - Stage 1和Stage 2的時間基準應該完全一致
   - Stage 2應正確繼承Stage 1的時間基準
   - 可見性識別數量應顯著提升（目標>3,000顆）

### Step 3: Skyfield庫整合

1. **安裝Skyfield依賴**:
   ```bash
   # 在容器內安裝Skyfield
   docker exec satellite-dev pip install skyfield
   ```

2. **創建Skyfield計算引擎**:
   - 創建 `src/shared/engines/skyfield_sgp4_engine.py`
   - 實現統一的Skyfield計算接口

3. **逐步替換計算邏輯**:
   - 先替換Stage 1的軌道計算
   - 再替換Stage 2的座標轉換
   - 保持API兼容性

### Step 4: 全面測試驗證

1. **單階段測試**:
   ```bash
   # 測試每個修復後的階段
   docker exec satellite-dev python scripts/test_stage1_v6.py
   docker exec satellite-dev python scripts/test_stage2_v6.py
   ```

2. **集成測試**:
   ```bash
   # 測試完整的Stage 1+2流程
   docker exec satellite-dev python scripts/run_stage1_stage2_integration_test.py
   ```

3. **性能比較測試**:
   ```bash
   # 比較v6.0修復前後的性能
   docker exec satellite-dev python scripts/compare_v6_performance.py
   ```

## 📊 預期成果指標

### 🎯 關鍵成功指標

| 指標 | 修復前 | v6.0目標 | 驗證方式 |
|------|--------|----------|----------|
| Stage 2可見衛星數 | 2,272顆 | >3,000顆 | 執行結果統計 |
| 時間基準一致性 | 不一致 | 100%一致 | metadata檢查 |
| 計算精度等級 | 公里級 | 米級 | Skyfield集成檢查 |
| 學術標準合規 | Grade B+ | Grade A++ | 合規驗證通過 |
| 零可見性問題 | 存在 | 完全解決 | 可見性結果驗證 |

### 🚨 回滾準備

**回滾條件**:
- v6.0修復後Stage 2識別衛星數 < 2,000顆
- 任何關鍵驗證項目失敗
- 系統穩定性嚴重下降

**回滾方法**:
```bash
# 1. 備份當前v6.0代碼
cp -r src/stages src/stages_v6_backup

# 2. 恢復v5.1版本代碼
git checkout v5.1 -- src/stages/

# 3. 重新測試系統穩定性
docker exec satellite-dev python scripts/run_six_stages_with_validation.py
```

## 🔄 持續改進計劃

### Phase 1: 基礎修復 (當前)
- ✅ Stage 1時間基準修復
- ✅ Stage 2時間基準繼承
- 🔄 基礎驗證框架增強

### Phase 2: 精度提升 (後續)
- Skyfield庫全面整合
- 高精度計算標準化
- 性能優化

### Phase 3: 全系統統一 (長期)
- Stage 3-6時間基準繼承
- 全系統Skyfield標準化
- 完整學術合規保證

---

**本指導文檔將指導完整的v6.0重構實施，確保六階段系統達到學術級精度和一致性標準。**

*創建日期：2025-09-17 | v6.0 重構指導文檔 1.0.0*