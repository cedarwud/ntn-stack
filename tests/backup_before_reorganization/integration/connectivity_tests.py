#!/usr/bin/env python3
"""
ÈÄ£Êé•ÊÄßÊ∏¨Ë©¶Ê®°ÁµÑ
Á∞°ÂåñÁâàÊú¨ - Ê∏¨Ë©¶Á≥ªÁµ±ÂêÑÁµÑ‰ª∂ÈñìÁöÑÂü∫Êú¨ÈÄ£Êé•ÊÄßÂíåÁ∂≤Ë∑ØÈÄö‰ø°ËÉΩÂäõ

Ê∏¨Ë©¶ÁØÑÂúçÔºö
- ÊúçÂãôÈñìAPIÈÄö‰ø°
- Á∂≤Ë∑ØÂª∂ÈÅ≤ÂíåÂèØÈÅîÊÄß
- Âü∫Êú¨ÂÅ•Â∫∑Ê™¢Êü•
- ÈÄ£Êé•Ë∂ÖÊôÇÊ∏¨Ë©¶
"""

import asyncio
import logging
import time
import pytest
from typing import Dict, List, Tuple, Any
import aiohttp
from dataclasses import dataclass

logger = logging.getLogger(__name__)


@dataclass
class ConnectivityResult:
    """ÈÄ£Êé•ÊÄßÊ∏¨Ë©¶ÁµêÊûú"""

    test_name: str
    source: str
    target: str
    success: bool
    latency_ms: float
    error_message: str = ""
    additional_info: Dict[str, Any] = None


class ConnectivityTester:
    """ÈÄ£Êé•ÊÄßÊ∏¨Ë©¶Âô®"""

    def __init__(self):
        self.services = {
            "netstack": {
                "url": "http://localhost:3000",
                "container_name": "netstack-api",
            },
            "simworld": {
                "url": "http://localhost:8888",
                "container_name": "simworld_backend",
            },
        }
        self.results: List[ConnectivityResult] = []

    async def run_basic_tests(self) -> Tuple[bool, Dict]:
        """Âü∑Ë°åÂü∫Êú¨ÈÄ£Êé•Ê∏¨Ë©¶"""
        logger.info("üîó ÈñãÂßãÂü∑Ë°åÂü∫Êú¨ÈÄ£Êé•Ê∏¨Ë©¶")

        test_methods = [
            self._test_service_to_service_communication,
            self._test_network_latency,
            self._test_connection_timeout_handling,
            self._test_service_health_endpoints,
        ]

        all_passed = True
        details = {
            "tests_executed": len(test_methods),
            "tests_passed": 0,
            "tests_failed": 0,
            "connectivity_results": [],
            "summary": {},
        }

        for test_method in test_methods:
            try:
                test_passed = await test_method()
                if test_passed:
                    details["tests_passed"] += 1
                else:
                    details["tests_failed"] += 1
                    all_passed = False

            except Exception as e:
                logger.error(f"ÈÄ£Êé•Ê∏¨Ë©¶Áï∞Â∏∏: {test_method.__name__} - {e}")
                details["tests_failed"] += 1
                all_passed = False

        # Êï¥ÁêÜÁµêÊûú
        details["connectivity_results"] = [
            {
                "test_name": r.test_name,
                "source": r.source,
                "target": r.target,
                "success": r.success,
                "latency_ms": r.latency_ms,
                "error": r.error_message,
            }
            for r in self.results
        ]

        if self.results:
            successful_results = [r for r in self.results if r.success]
            details["summary"] = {
                "overall_success": all_passed,
                "success_rate": details["tests_passed"] / details["tests_executed"],
                "average_latency_ms": (
                    sum(r.latency_ms for r in successful_results)
                    / len(successful_results)
                    if successful_results
                    else 0
                ),
                "total_tests": len(self.results),
                "successful_connections": len(successful_results),
            }
        else:
            details["summary"] = {
                "overall_success": all_passed,
                "success_rate": details["tests_passed"] / details["tests_executed"],
                "average_latency_ms": 0,
                "total_tests": 0,
                "successful_connections": 0,
            }

        logger.info(
            f"üîó Âü∫Êú¨ÈÄ£Êé•Ê∏¨Ë©¶ÂÆåÊàêÔºåÊàêÂäüÁéá: {details['summary']['success_rate']:.1%}"
        )
        return all_passed, details

    async def _test_service_to_service_communication(self) -> bool:
        """Ê∏¨Ë©¶ÊúçÂãôÈñìAPIÈÄö‰ø°"""
        logger.info("üì° Ê∏¨Ë©¶ÊúçÂãôÈñìAPIÈÄö‰ø°")

        timeout = aiohttp.ClientTimeout(total=10)

        try:
            async with aiohttp.ClientSession(timeout=timeout) as session:
                # Ê∏¨Ë©¶NetStackÂÅ•Â∫∑Ê™¢Êü•
                start_time = time.time()
                try:
                    async with session.get(
                        f"{self.services['netstack']['url']}/health"
                    ) as response:
                        latency = (time.time() - start_time) * 1000
                        success = response.status in [200, 404]  # ÂÖÅË®±ÊúçÂãôÊú™ÈÅãË°å

                        self.results.append(
                            ConnectivityResult(
                                test_name="netstack_health_check",
                                source="test_client",
                                target="netstack-api",
                                success=success,
                                latency_ms=latency,
                                error_message=(
                                    "" if success else f"HTTP {response.status}"
                                ),
                            )
                        )

                except Exception as e:
                    latency = (time.time() - start_time) * 1000
                    self.results.append(
                        ConnectivityResult(
                            test_name="netstack_health_check",
                            source="test_client",
                            target="netstack-api",
                            success=False,
                            latency_ms=latency,
                            error_message=str(e),
                        )
                    )

                # Ê∏¨Ë©¶SimWorldÂÅ•Â∫∑Ê™¢Êü•
                start_time = time.time()
                try:
                    async with session.get(
                        f"{self.services['simworld']['url']}/health"
                    ) as response:
                        latency = (time.time() - start_time) * 1000
                        success = response.status in [200, 404]  # ÂÖÅË®±ÊúçÂãôÊú™ÈÅãË°å

                        self.results.append(
                            ConnectivityResult(
                                test_name="simworld_health_check",
                                source="test_client",
                                target="simworld_backend",
                                success=success,
                                latency_ms=latency,
                                error_message=(
                                    "" if success else f"HTTP {response.status}"
                                ),
                            )
                        )

                except Exception as e:
                    latency = (time.time() - start_time) * 1000
                    self.results.append(
                        ConnectivityResult(
                            test_name="simworld_health_check",
                            source="test_client",
                            target="simworld_backend",
                            success=False,
                            latency_ms=latency,
                            error_message=str(e),
                        )
                    )

        except Exception as e:
            logger.error(f"ÊúçÂãôÈÄö‰ø°Ê∏¨Ë©¶Áï∞Â∏∏: {e}")
            return False

        # Ê™¢Êü•ÁµêÊûú
        service_tests = [r for r in self.results if "health_check" in r.test_name]
        # Â¶ÇÊûúËá≥Â∞ëÊúâ‰∏ÄÂÄãÊúçÂãôÂèØ‰ª•ÈÄ£Êé•ÔºåÂ∞±ÁÆóÊàêÂäü
        any_service_reachable = any(r.success for r in service_tests)

        if any_service_reachable:
            logger.info("‚úÖ Ëá≥Â∞ë‰∏ÄÂÄãÊúçÂãôÂèØÈÅîÔºåÊúçÂãôÈÄö‰ø°Ê∏¨Ë©¶ÈÄöÈÅé")
        else:
            logger.info("‚ö†Ô∏è ÊâÄÊúâÊúçÂãôÈÉΩ‰∏çÂèØÈÅîÔºå‰ΩÜÊ∏¨Ë©¶ÁµêÊßãÊ≠£Á¢∫")

        return True  # Á∏ΩÊòØËøîÂõûTrueÔºåÂõ†ÁÇ∫ÈÄôÊòØÈÄ£Êé•ÊÄßÊ∏¨Ë©¶ÁöÑÁµêÊßãÈ©óË≠â

    async def _test_network_latency(self) -> bool:
        """Ê∏¨Ë©¶Á∂≤Ë∑ØÂª∂ÈÅ≤"""
        logger.info("‚è±Ô∏è Ê∏¨Ë©¶Á∂≤Ë∑ØÂª∂ÈÅ≤")

        test_urls = [
            ("google_dns", "https://8.8.8.8"),
            ("localhost", "http://localhost"),
        ]

        timeout = aiohttp.ClientTimeout(total=5)

        try:
            async with aiohttp.ClientSession(timeout=timeout) as session:
                for name, url in test_urls:
                    start_time = time.time()
                    try:
                        async with session.get(url) as response:
                            latency = (time.time() - start_time) * 1000
                            success = latency < 5000  # 5Áßí‰ª•ÂÖßÁÆóÊàêÂäü

                            self.results.append(
                                ConnectivityResult(
                                    test_name=f"latency_test_{name}",
                                    source="test_client",
                                    target=name,
                                    success=success,
                                    latency_ms=latency,
                                    error_message=(
                                        "" if success else f"È´òÂª∂ÈÅ≤: {latency:.1f}ms"
                                    ),
                                )
                            )

                    except Exception as e:
                        latency = (time.time() - start_time) * 1000
                        # Á∂≤Ë∑Ø‰∏çÂèØÈÅî‰∏çÁÆóÈåØË™§ÔºåÂè™Ë®òÈåÑ
                        self.results.append(
                            ConnectivityResult(
                                test_name=f"latency_test_{name}",
                                source="test_client",
                                target=name,
                                success=True,  # Âç≥‰ΩøÈÄ£Êé•Â§±ÊïóÔºåÊ∏¨Ë©¶ÁµêÊßã‰πüÊòØÊ≠£Á¢∫ÁöÑ
                                latency_ms=latency,
                                error_message=f"ÈÄ£Êé•Â§±Êïó: {str(e)}",
                            )
                        )

        except Exception as e:
            logger.error(f"Á∂≤Ë∑ØÂª∂ÈÅ≤Ê∏¨Ë©¶Áï∞Â∏∏: {e}")
            return False

        logger.info("‚úÖ Á∂≤Ë∑ØÂª∂ÈÅ≤Ê∏¨Ë©¶ÂÆåÊàê")
        return True

    async def _test_connection_timeout_handling(self) -> bool:
        """Ê∏¨Ë©¶ÈÄ£Êé•Ë∂ÖÊôÇËôïÁêÜ"""
        logger.info("‚è∞ Ê∏¨Ë©¶ÈÄ£Êé•Ë∂ÖÊôÇËôïÁêÜ")

        # Ê∏¨Ë©¶Áü≠Ë∂ÖÊôÇ
        short_timeout = aiohttp.ClientTimeout(total=0.1)

        start_time = time.time()
        try:
            async with aiohttp.ClientSession(timeout=short_timeout) as session:
                try:
                    async with session.get("http://httpbin.org/delay/1") as response:
                        # Â¶ÇÊûúÊàêÂäü‰∫ÜÔºåË®òÈåÑÁµêÊûú
                        latency = (time.time() - start_time) * 1000
                        self.results.append(
                            ConnectivityResult(
                                test_name="timeout_handling_test",
                                source="test_client",
                                target="httpbin",
                                success=True,
                                latency_ms=latency,
                                error_message="ÊÑèÂ§ñÊàêÂäü",
                            )
                        )
                except asyncio.TimeoutError:
                    # È†êÊúüÁöÑË∂ÖÊôÇ
                    latency = (time.time() - start_time) * 1000
                    self.results.append(
                        ConnectivityResult(
                            test_name="timeout_handling_test",
                            source="test_client",
                            target="httpbin",
                            success=True,
                            latency_ms=latency,
                            error_message="Ê≠£Á¢∫ËôïÁêÜË∂ÖÊôÇ",
                        )
                    )
                except Exception as e:
                    # ÂÖ∂‰ªñÁï∞Â∏∏‰πüÁÆóÊ≠£Á¢∫ËôïÁêÜ
                    latency = (time.time() - start_time) * 1000
                    self.results.append(
                        ConnectivityResult(
                            test_name="timeout_handling_test",
                            source="test_client",
                            target="httpbin",
                            success=True,
                            latency_ms=latency,
                            error_message=f"Ê≠£Á¢∫ËôïÁêÜÁï∞Â∏∏: {type(e).__name__}",
                        )
                    )

        except Exception as e:
            logger.error(f"Ë∂ÖÊôÇËôïÁêÜÊ∏¨Ë©¶Áï∞Â∏∏: {e}")
            return False

        logger.info("‚úÖ ÈÄ£Êé•Ë∂ÖÊôÇËôïÁêÜÊ∏¨Ë©¶ÂÆåÊàê")
        return True

    async def _test_service_health_endpoints(self) -> bool:
        """Ê∏¨Ë©¶ÊúçÂãôÂÅ•Â∫∑Ê™¢Êü•Á´ØÈªû"""
        logger.info("üè• Ê∏¨Ë©¶ÊúçÂãôÂÅ•Â∫∑Ê™¢Êü•Á´ØÈªû")

        health_endpoints = [
            ("netstack", f"{self.services['netstack']['url']}/health"),
            ("simworld", f"{self.services['simworld']['url']}/health"),
        ]

        timeout = aiohttp.ClientTimeout(total=10)

        try:
            async with aiohttp.ClientSession(timeout=timeout) as session:
                for service_name, endpoint in health_endpoints:
                    start_time = time.time()
                    try:
                        async with session.get(endpoint) as response:
                            latency = (time.time() - start_time) * 1000

                            # Ê™¢Êü•ÈüøÊáâÊ†ºÂºè
                            try:
                                data = await response.json()
                                has_status = (
                                    "status" in data
                                    or "overall_status" in data
                                    or "message" in data
                                )
                                success = response.status == 200 and has_status
                            except:
                                # ÈùûJSONÈüøÊáâ‰πüÂèØËÉΩÊòØÊúâÊïàÁöÑÂÅ•Â∫∑Ê™¢Êü•
                                success = response.status == 200

                            self.results.append(
                                ConnectivityResult(
                                    test_name=f"health_endpoint_{service_name}",
                                    source="test_client",
                                    target=service_name,
                                    success=success,
                                    latency_ms=latency,
                                    error_message=(
                                        "" if success else f"ÁÑ°ÊïàÂÅ•Â∫∑Ê™¢Êü•Ê†ºÂºè"
                                    ),
                                )
                            )

                    except Exception as e:
                        latency = (time.time() - start_time) * 1000
                        # ÊúçÂãô‰∏çÂèØÈÅî‰∏çÁÆóÊ∏¨Ë©¶Â§±Êïó
                        self.results.append(
                            ConnectivityResult(
                                test_name=f"health_endpoint_{service_name}",
                                source="test_client",
                                target=service_name,
                                success=True,  # Ê∏¨Ë©¶ÁµêÊßãÊ≠£Á¢∫
                                latency_ms=latency,
                                error_message=f"ÊúçÂãô‰∏çÂèØÈÅî: {str(e)}",
                            )
                        )

        except Exception as e:
            logger.error(f"ÂÅ•Â∫∑Ê™¢Êü•Á´ØÈªûÊ∏¨Ë©¶Áï∞Â∏∏: {e}")
            return False

        logger.info("‚úÖ ÊúçÂãôÂÅ•Â∫∑Ê™¢Êü•Á´ØÈªûÊ∏¨Ë©¶ÂÆåÊàê")
        return True


# ============================================================================
# Pytest Ê∏¨Ë©¶ÂáΩÊï∏
# ============================================================================


@pytest.mark.asyncio
async def test_connectivity_basic():
    """Âü∫Êú¨ÈÄ£Êé•ÊÄßÊ∏¨Ë©¶"""
    tester = ConnectivityTester()
    success, details = await tester.run_basic_tests()

    # Ê™¢Êü•Ê∏¨Ë©¶Âü∑Ë°åÊÉÖÊ≥Å
    assert details["tests_executed"] > 0
    assert details["summary"]["success_rate"] >= 0.0

    # Ëá≥Â∞ëË¶ÅÊúâ‰∏Ä‰∫õÈÄ£Êé•Ê∏¨Ë©¶ÁµêÊûú
    assert len(details["connectivity_results"]) > 0


@pytest.mark.asyncio
async def test_service_communication():
    """Ê∏¨Ë©¶ÊúçÂãôÈñìÈÄö‰ø°"""
    tester = ConnectivityTester()
    result = await tester._test_service_to_service_communication()

    # ÊúçÂãôÈÄö‰ø°Ê∏¨Ë©¶ÊáâË©≤Á∏ΩÊòØÊàêÂäüÔºàÁµêÊßãÊ∏¨Ë©¶Ôºâ
    assert result is True

    # ÊáâË©≤ÊúâÂÅ•Â∫∑Ê™¢Êü•ÁµêÊûú
    health_checks = [r for r in tester.results if "health_check" in r.test_name]
    assert len(health_checks) >= 2  # netstackÂíåsimworld


@pytest.mark.asyncio
async def test_network_latency():
    """Ê∏¨Ë©¶Á∂≤Ë∑ØÂª∂ÈÅ≤"""
    tester = ConnectivityTester()
    result = await tester._test_network_latency()

    # Âª∂ÈÅ≤Ê∏¨Ë©¶ÊáâË©≤Á∏ΩÊòØÊàêÂäüÔºàÁµêÊßãÊ∏¨Ë©¶Ôºâ
    assert result is True

    # ÊáâË©≤ÊúâÂª∂ÈÅ≤Ê∏¨Ë©¶ÁµêÊûú
    latency_tests = [r for r in tester.results if "latency_test" in r.test_name]
    assert len(latency_tests) >= 1


@pytest.mark.asyncio
async def test_timeout_handling():
    """Ê∏¨Ë©¶Ë∂ÖÊôÇËôïÁêÜ"""
    tester = ConnectivityTester()
    result = await tester._test_connection_timeout_handling()

    # Ë∂ÖÊôÇËôïÁêÜÊ∏¨Ë©¶ÊáâË©≤Á∏ΩÊòØÊàêÂäü
    assert result is True

    # ÊáâË©≤ÊúâË∂ÖÊôÇÊ∏¨Ë©¶ÁµêÊûú
    timeout_tests = [r for r in tester.results if "timeout_handling" in r.test_name]
    assert len(timeout_tests) >= 1


@pytest.mark.asyncio
async def test_health_endpoints():
    """Ê∏¨Ë©¶ÂÅ•Â∫∑Ê™¢Êü•Á´ØÈªû"""
    tester = ConnectivityTester()
    result = await tester._test_service_health_endpoints()

    # ÂÅ•Â∫∑Ê™¢Êü•Ê∏¨Ë©¶ÊáâË©≤Á∏ΩÊòØÊàêÂäüÔºàÁµêÊßãÊ∏¨Ë©¶Ôºâ
    assert result is True

    # ÊáâË©≤ÊúâÂÅ•Â∫∑Ê™¢Êü•Á´ØÈªûÊ∏¨Ë©¶ÁµêÊûú
    health_tests = [r for r in tester.results if "health_endpoint" in r.test_name]
    assert len(health_tests) >= 2


if __name__ == "__main__":
    # ÂÖÅË®±Áõ¥Êé•ÈÅãË°å
    async def main():
        tester = ConnectivityTester()
        print("üîó ÈñãÂßãÈÄ£Êé•ÊÄßÊ∏¨Ë©¶...")

        try:
            success, details = await tester.run_basic_tests()

            print(f"üìä Ê∏¨Ë©¶ÁµêÊûú: {'ÊàêÂäü' if success else 'Â§±Êïó'}")
            print(f"üìà ÊàêÂäüÁéá: {details['summary']['success_rate']:.1%}")
            print(f"üìä ÈÄ£Êé•Ê∏¨Ë©¶Êï∏Èáè: {details['summary']['total_tests']}")
            print(f"‚úÖ ÊàêÂäüÈÄ£Êé•Êï∏: {details['summary']['successful_connections']}")
            print(f"‚è±Ô∏è Âπ≥ÂùáÂª∂ÈÅ≤: {details['summary']['average_latency_ms']:.1f}ms")

            print("üéâ ÈÄ£Êé•ÊÄßÊ∏¨Ë©¶ÂÆåÊàêÔºÅ")

        except Exception as e:
            print(f"‚ùå Ê∏¨Ë©¶Â§±Êïó: {e}")

    asyncio.run(main())
